//===-- Executor.cpp ------------------------------------------------------===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "Common.h"
#include "Executor.h"
#include "Context.h"
#include "CoreStats.h"
#include "ExternalDispatcher.h"
#include "ImpliedValue.h"
#include "Memory.h"
#include "MemoryManager.h"
#include "PTree.h"
#include "Searcher.h"
#include "SeedInfo.h"
#include "SpecialFunctionHandler.h"
#include "StatsTracker.h"
#include "TimingSolver.h"
#include "UserSearcher.h"
#include "ExecutorTimerInfo.h"
#include "klee/ExecutorCommandLineParameters.h"

#include "../Solver/SolverStats.h"

#include "klee/PathManager.h"
#include "klee/ExecutionState.h"
#include "klee/Expr.h"
#include "klee/Interpreter.h"
#include "klee/TimerStatIncrementer.h"
#include "klee/CommandLine.h"
#include "klee/Common.h"
#include "klee/util/Assignment.h"
#include "klee/util/ExprPPrinter.h"
#include "klee/util/ExprSMTLIBPrinter.h"
#include "klee/util/ExprUtil.h"
#include "klee/util/GetElementPtrTypeIterator.h"
#include "klee/Config/Version.h"
#include "klee/Internal/ADT/KTest.h"
#include "klee/Internal/ADT/RNG.h"
#include "klee/Internal/Module/Cell.h"
#include "klee/Internal/Module/InstructionInfoTable.h"
#include "klee/Internal/Module/KInstruction.h"
#include "klee/Internal/Module/KModule.h"
#include "klee/Internal/Support/FloatEvaluation.h"
#include "klee/Internal/System/Time.h"
#include "klee/Internal/System/MemoryUsage.h"

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
#include "llvm/IR/Function.h"
#include "llvm/IR/Attributes.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/TypeBuilder.h"
#else
#include "llvm/Attributes.h"
#include "llvm/BasicBlock.h"
#include "llvm/Constants.h"
#include "llvm/Function.h"
#include "llvm/Instructions.h"
#include "llvm/IntrinsicInst.h"
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#if LLVM_VERSION_CODE <= LLVM_VERSION(3, 1)
#include "llvm/Target/TargetData.h"
#else
#include "llvm/DataLayout.h"
#include "llvm/TypeBuilder.h"
#endif
#endif
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/raw_ostream.h"

#if LLVM_VERSION_CODE < LLVM_VERSION(3, 5)
#include "llvm/Support/CallSite.h"
#else
#include "llvm/IR/CallSite.h"
#endif

#include <cassert>
#include <algorithm>
#include <iomanip>
#include <iosfwd>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>

#include <sys/mman.h>

#include <errno.h>
#include <cxxabi.h>
#include <iostream>

using namespace llvm;
using namespace klee;


#ifdef SUPPORT_METASMT

#include <metaSMT/frontend/Array.hpp>
#include <metaSMT/backend/Z3_Backend.hpp>
#include <metaSMT/backend/Boolector.hpp>
#include <metaSMT/backend/MiniSAT.hpp>
#include <metaSMT/DirectSolver_Context.hpp>
#include <metaSMT/support/run_algorithm.hpp>
#include <metaSMT/API/Stack.hpp>
#include <metaSMT/API/Group.hpp>

#define Expr VCExpr
#define Type VCType
#define STP STP_Backend
#include <metaSMT/backend/STP.hpp>
#undef Expr
#undef Type
#undef STP

using namespace metaSMT;
using namespace metaSMT::solver;

#endif /* SUPPORT_METASMT */



//namespace {
  //enum OP_Frequency{ NeverFreq, BBLFreq, InstructionFreq };
  //cl::opt<std::string>
  //StartFunction("start-fn",
  //                 cl::init("main"),
	//	   cl::desc("Call-path start function"));

  //cl::opt<std::string>
  //TargetFunction("target-fn",
  //                 cl::init("assert"),
	//	   cl::desc("Create a path toward invocation of this function"));

  cl::opt<bool>
  DumpStatesOnHalt("dump-states-on-halt",
                   cl::init(true),
		   cl::desc("Dump test cases for all active states on exit (default=on)"));

  cl::opt<bool>
  PruneMode("prune", 
        cl::init(false),
        cl::desc("Check for and eliminate duplicate states"));
 
  cl::opt<bool>
  RandomizeFork("randomize-fork",
                cl::init(false),
		cl::desc("Randomly swap the true and false states on a fork (default=off)"));
 
  cl::opt<bool>
  AllowExternalSymCalls("allow-external-sym-calls",
                        cl::init(false),
			cl::desc("Allow calls with symbolic arguments to external functions.  This concretizes the symbolic arguments.  (default=off)"));

  cl::opt<bool>
  DebugPrintInstructions("debug-print-instructions", 
                         cl::desc("Print instructions during execution."));

  cl::opt<bool>
  DebugCheckForImpliedValues("debug-check-for-implied-values");


  cl::opt<bool>
  SimplifySymIndices("simplify-sym-indices",
                     cl::init(false));

  cl::opt<bool>
  EqualitySubstitution("equality-substitution",
                     cl::init(true),
                     cl::desc("Simplify equality expressions before querying the solver (default=on)."));

  cl::opt<unsigned>
  MaxSymArraySize("max-sym-array-size",
                  cl::init(0));

  cl::opt<bool>
  SuppressExternalWarnings("suppress-external-warnings");

  cl::opt<bool>
  AllExternalWarnings("all-external-warnings");

  cl::opt<bool>
  OnlyOutputStatesCoveringNew("only-output-states-covering-new",
                              cl::init(false),
			      cl::desc("Only output test cases covering new code."));

  cl::opt<bool>
  EmitAllErrors("emit-all-errors",
                cl::init(false),
                cl::desc("Generate tests cases for all errors "
                         "(default=off, i.e. one per (error,instruction) pair)"));
  
  cl::opt<bool>
  NoExternals("no-externals", 
           cl::desc("Do not allow external function calls (default=off)"));

  cl::opt<bool>
  AlwaysOutputSeeds("always-output-seeds",
		    cl::init(true));

  cl::opt<bool>
  OnlyReplaySeeds("only-replay-seeds", 
                  cl::desc("Discard states that do not have a seed."));
 
  cl::opt<bool>
  OnlySeed("only-seed", 
           cl::desc("Stop execution after seeding is done without doing regular search."));
 
  cl::opt<bool>
  AllowSeedExtension("allow-seed-extension", 
                     cl::desc("Allow extra (unbound) values to become symbolic during seeding."));
 
  cl::opt<bool>
  ZeroSeedExtension("zero-seed-extension");
 
  cl::opt<bool>
  AllowSeedTruncation("allow-seed-truncation", 
                      cl::desc("Allow smaller buffers than in seeds."));
 
  cl::opt<bool>
  NamedSeedMatching("named-seed-matching",
                    cl::desc("Use names to match symbolic objects to inputs."));

  cl::opt<double>
  MaxStaticForkPct("max-static-fork-pct", cl::init(1.));
  cl::opt<double>
  MaxStaticSolvePct("max-static-solve-pct", cl::init(1.));
  cl::opt<double>
  MaxStaticCPForkPct("max-static-cpfork-pct", cl::init(1.));
  cl::opt<double>
  MaxStaticCPSolvePct("max-static-cpsolve-pct", cl::init(1.));

  cl::opt<double>
  MaxInstructionTime("max-instruction-time",
                     cl::desc("Only allow a single instruction to take this much time (default=0s (off)). Enables --use-forked-solver"),
                     cl::init(0));
  
  cl::opt<double>
  SeedTime("seed-time",
           cl::desc("Amount of time to dedicate to seeds, before normal search (default=0 (off))"),
           cl::init(0));
  
  cl::opt<unsigned int>
  StopAfterNInstructions("stop-after-n-instructions",
                         cl::desc("Stop execution after specified number of instructions (default=0 (off))"),
                         cl::init(0));
  
  cl::opt<unsigned>
  MaxForks("max-forks",
           cl::desc("Only fork this many times (default=-1 (off))"),
           cl::init(~0u));
  
  cl::opt<unsigned>
  MaxDepth("max-depth",
           cl::desc("Only allow this many symbolic branches (default=0 (off))"),
           cl::init(0));
  
  cl::opt<unsigned>
  MaxMemory("max-memory",
            cl::desc("Refuse to fork when above this amount of memory (in MB, default=2000)"),
            cl::init(2000));

  cl::opt<bool>
  MaxMemoryInhibit("max-memory-inhibit",
            cl::desc("Inhibit forking at memory cap (vs. random terminate) (default=on)"),
            cl::init(true));

  cl::opt<OP_Frequency>
  ISRFrequency("isr-frequency",
            cl::desc("ISR Frequency: (default: Basic Block level)"),
            cl::Prefix,
            cl::values(clEnumVal(NeverFreq,  "Never"),
                       clEnumVal(BBLFreq,    "Every Basic Block"),
                       clEnumVal(InstructionFreq,  "Every Instruction"),
                       clEnumValEnd),
            cl::init(BBLFreq));

	cl::opt<OP_Frequency>
  MergeFrequency("merge-frequency",
            cl::desc("Merge Frequency: (default: Basic Block level)"),
            cl::Prefix,
            cl::values(clEnumVal(NeverFreq,  "Never"),
                       clEnumVal(BBLFreq,   "Every Basic Block"),
                       clEnumVal(InstructionFreq,  "Every Instruction"),
                       clEnumValEnd),
            cl::init(BBLFreq));
//}


namespace klee {
  RNG theRNG;
}

void print_expressions(std::vector<ref<Expr> > vexpr);
unsigned getIntTypeWidth(llvm::Type *type);
unsigned getPointerTypeElementWidth(llvm::Type *type);

void Executor::setArch(Architecture * _arch){
	arch = _arch;
  memory->arch = _arch;
}


/// IVAN ADDITIOND BEGIN
Executor::Executor(const InterpreterOptions &opts, InterpreterHandler *ih, Solver *coreSolver) 
  : Interpreter(opts),
    kmodule(0),
    interpreterHandler(ih),
    searcher(0),
    externalDispatcher(new ExternalDispatcher()),
    statsTracker(0),
    pathWriter(0),
    symPathWriter(0),
    specialFunctionHandler(0),
    processTree(0),
    replayOut(0),
    replayPath(0),    
    usingSeeds(0),
    atMemoryLimit(false),
    inhibitForking(false),
    haltExecution(false),
    ivcEnabled(false),
    coreSolverTimeout(MaxCoreSolverTime != 0 && MaxInstructionTime != 0
      ? std::min(MaxCoreSolverTime,MaxInstructionTime)
      : std::max(MaxCoreSolverTime,MaxInstructionTime)) {
      
  
  Solver *solver = 
    constructSolverChain(coreSolver,
                         interpreterHandler->getOutputFilename(ALL_QUERIES_SMT2_FILE_NAME),
                         interpreterHandler->getOutputFilename(SOLVER_QUERIES_SMT2_FILE_NAME),
                         interpreterHandler->getOutputFilename(ALL_QUERIES_PC_FILE_NAME),
                         interpreterHandler->getOutputFilename(SOLVER_QUERIES_PC_FILE_NAME));
  
  this->solver = new TimingSolver(solver, EqualitySubstitution);

  memory = new MemoryManager();
}
/// IVAN ADDITIOND END

Executor::Executor(const InterpreterOptions &opts,
                   InterpreterHandler *ih) 
  : Interpreter(opts),
    kmodule(0),
    interpreterHandler(ih),
    searcher(0),
    externalDispatcher(new ExternalDispatcher()),
    statsTracker(0),
    pathWriter(0),
    symPathWriter(0),
    specialFunctionHandler(0),
    processTree(0),
    replayOut(0),
    replayPath(0),    
    usingSeeds(0),
    atMemoryLimit(false),
    inhibitForking(false),
    haltExecution(false),
    ivcEnabled(false),
    coreSolverTimeout(MaxCoreSolverTime != 0 && MaxInstructionTime != 0
      ? std::min(MaxCoreSolverTime,MaxInstructionTime)
      : std::max(MaxCoreSolverTime,MaxInstructionTime)) {
      
  if (coreSolverTimeout) UseForkedCoreSolver = true;
  //llvm::outs() << "Executor::Executor(): MaxCoreSolverTime = " << MaxCoreSolverTime 
  //             << ", MaxInstructionTime = " << MaxInstructionTime << "\n";
  //llvm::outs() << "Executor::Executor(): UseForkedCoreSolver = " << (UseForkedCoreSolver ? "true\n" : "false\n");
  
  Solver *coreSolver = NULL;
  
#ifdef SUPPORT_METASMT
  if (UseMetaSMT != METASMT_BACKEND_NONE) {
    
    std::string backend;
    
    switch (UseMetaSMT) {
          case METASMT_BACKEND_STP:
              backend = "STP"; 
              coreSolver = new MetaSMTSolver< DirectSolver_Context < STP_Backend > >(UseForkedCoreSolver, CoreSolverOptimizeDivides);
              break;
          case METASMT_BACKEND_Z3:
              backend = "Z3";
              coreSolver = new MetaSMTSolver< DirectSolver_Context < Z3_Backend > >(UseForkedCoreSolver, CoreSolverOptimizeDivides);
              break;
          case METASMT_BACKEND_BOOLECTOR:
              backend = "Boolector";
              coreSolver = new MetaSMTSolver< DirectSolver_Context < Boolector > >(UseForkedCoreSolver, CoreSolverOptimizeDivides);
              break;
          default:
              assert(false);
              break;
    };
    llvm::errs() << "Starting MetaSMTSolver(" << backend << ") ...\n";
  }
  else {
    coreSolver = new STPSolver(UseForkedCoreSolver, CoreSolverOptimizeDivides);
  }
#else
  coreSolver = new STPSolver(UseForkedCoreSolver, CoreSolverOptimizeDivides);
#endif /* SUPPORT_METASMT */
  
   
  Solver *solver = 
    constructSolverChain(coreSolver,
                         interpreterHandler->getOutputFilename(ALL_QUERIES_SMT2_FILE_NAME),
                         interpreterHandler->getOutputFilename(SOLVER_QUERIES_SMT2_FILE_NAME),
                         interpreterHandler->getOutputFilename(ALL_QUERIES_PC_FILE_NAME),
                         interpreterHandler->getOutputFilename(SOLVER_QUERIES_PC_FILE_NAME));
  
  this->solver = new TimingSolver(solver, EqualitySubstitution);

  memory = new MemoryManager();
}


void Executor::setModule(KModule *_kmodule) 
{
  assert(!kmodule && "can only register one module"); // XXX gross
 
  llvm::outs() << "Executor::setModule(): Inside\n";
  kmodule = _kmodule;
  specialFunctionHandler = new SpecialFunctionHandler(*this);

  specialFunctionHandler->prepare();
  specialFunctionHandler->bind();

  if (StatsTracker::useStatistics()) {
    statsTracker = 
      new StatsTracker(*this,
                       interpreterHandler->getOutputFilename("assembly.ll"),
                       userSearcherRequiresMD2U());
  }
  return;
}

/* We don't use this method anymore */
const Module *Executor::setModule(llvm::Module *module, 
                                  const ModuleOptions &opts) {
  assert(!kmodule && module && "can only register one module"); // XXX gross
  
  kmodule = new KModule(module);

  // Initialize the context.
#if LLVM_VERSION_CODE <= LLVM_VERSION(3, 1)
  TargetData *TD = kmodule->targetData;
#else
  DataLayout *TD = kmodule->targetData;
#endif
  Context::initialize(TD->isLittleEndian(),
                      (Expr::Width) TD->getPointerSizeInBits());

  specialFunctionHandler = new SpecialFunctionHandler(*this);

  specialFunctionHandler->prepare();
  kmodule->prepare(opts, interpreterHandler);
  specialFunctionHandler->bind();

  if (StatsTracker::useStatistics()) {
    statsTracker = 
      new StatsTracker(*this,
                       interpreterHandler->getOutputFilename("assembly.ll"),
                       userSearcherRequiresMD2U());
  }
  
  return module;
}


Executor::~Executor() {
  delete memory;
  delete externalDispatcher;
  if (processTree)
    delete processTree;
  if (specialFunctionHandler)
    delete specialFunctionHandler;
  if (statsTracker)
    delete statsTracker;
  delete solver;
  delete kmodule;
  while(!timers.empty()) {
    delete timers.back();
    timers.pop_back();
  }
}

/***/

void Executor::initializeGlobalObject(ExecutionState &state, ObjectState *os,
                                      const Constant *c, 
                                      unsigned offset) {
#if LLVM_VERSION_CODE <= LLVM_VERSION(3, 1)
  TargetData *targetData = kmodule->targetData;
#else
  DataLayout *targetData = kmodule->targetData;
#endif
  if (const ConstantVector *cp = dyn_cast<ConstantVector>(c)) {
    unsigned elementSize =
      targetData->getTypeStoreSize(cp->getType()->getElementType());
    for (unsigned i=0, e=cp->getNumOperands(); i != e; ++i)
      initializeGlobalObject(state, os, cp->getOperand(i), 
			     offset + i*elementSize);
  } else if (isa<ConstantAggregateZero>(c)) {
    unsigned i, size = targetData->getTypeStoreSize(c->getType());
    for (i=0; i<size; i++)
      os->write8(offset+i, (uint8_t) 0);
  } else if (const ConstantArray *ca = dyn_cast<ConstantArray>(c)) {
    unsigned elementSize =
      targetData->getTypeStoreSize(ca->getType()->getElementType());
    for (unsigned i=0, e=ca->getNumOperands(); i != e; ++i)
      initializeGlobalObject(state, os, ca->getOperand(i), 
			     offset + i*elementSize);
  } else if (const ConstantStruct *cs = dyn_cast<ConstantStruct>(c)) {
    const StructLayout *sl =
      targetData->getStructLayout(cast<StructType>(cs->getType()));
    for (unsigned i=0, e=cs->getNumOperands(); i != e; ++i)
      initializeGlobalObject(state, os, cs->getOperand(i), 
			     offset + sl->getElementOffset(i));
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 1)
  } else if (const ConstantDataSequential *cds =
               dyn_cast<ConstantDataSequential>(c)) {
    unsigned elementSize =
      targetData->getTypeStoreSize(cds->getElementType());
    for (unsigned i=0, e=cds->getNumElements(); i != e; ++i)
      initializeGlobalObject(state, os, cds->getElementAsConstant(i),
                             offset + i*elementSize);
#endif
  } else if (!isa<UndefValue>(c)) {
    unsigned StoreBits = targetData->getTypeStoreSizeInBits(c->getType());
    ref<ConstantExpr> C = evalConstant(c);

    // Extend the constant if necessary;
    assert(StoreBits >= C->getWidth() && "Invalid store size!");
    if (StoreBits > C->getWidth())
      C = C->ZExt(StoreBits);

    os->write(offset, C);
  }
}

MemoryObject * Executor::addExternalObject(ExecutionState &state, 
                                           void *addr, unsigned size, 
                                           bool isReadOnly) {
  MemoryObject *mo = memory->allocateFixed((uint64_t) (unsigned long) addr, 
                                           size, 0);
  ObjectState *os = bindObjectInState(state, mo, false);
  for(unsigned i = 0; i < size; i++)
    os->write8(i, ((uint8_t*)addr)[i]);
  if(isReadOnly)
    os->setReadOnly(true);  
  return mo;
}

/* Create memory objects for flash segments, and periperal registers */
void Executor::initializeSpecialGlobals(ExecutionState& state) 
{
  Module *m = kmodule->module;

  /* Allocate memory for the status register. Obviously status register is not a part of RAM,
   * but we need to have a memory object in order to keep per-state values */
  { // new block to limit the scope of the variables and reuse the same names later
    llvm::outs() << "Executor::initializeSpecialGlobals(): initializing status register\n";
    MemoryObject *mo = memory->allocate(arch->pointer_size, false, true, NULL);
    if (!mo)
      llvm::report_fatal_error("out of memory");
    ObjectState *os = bindObjectInState(state, mo, false);
    //globalObjects.insert(std::make_pair(i, mo));
    //globalAddresses.insert(std::make_pair(i, mo->getBaseExpr()));
    os->initializeToZero();

    outs() << "Executor::initializeSpecialGlobals(): About to set status register\n";
    ref<Expr> sr_base = mo->getBaseExpr();
    arch->statusRegisterAddress = cast<ConstantExpr>(sr_base);
    llvm::outs() << "done setting status register\n";
  }


  /* Create new memory object for each of the flash memory segments and bind it
   * the state. Flash memroy is presistent memory, so should be defined. */
  for (std::vector<FlashMemory *>::iterator flashItr = arch->flashSegs.begin();
            flashItr != arch->flashSegs.end(); ++flashItr) 
  {
    FlashMemory *mem = *flashItr;
    uint64_t size = mem->end - mem->begin + 1;
    outs() << "Executor::initializeSpecialGlobals(): Allocating fixed flash memory region: [" << mem->begin << "-" << mem->end << "]\n";
    MemoryObject * mo = memory->allocateFixed(mem->begin, size, NULL);
    ObjectState *os = bindObjectInState(state, mo, false);
    os->initializeToZero();
  }

  /* Create new memory object for each of the periperal registers (e.g. ADC10MEM),
   * and initalize them with fresh symbolic values */
  for (std::map<std::string, SpecialMemory *>::iterator specLocItr = arch->namedAddresses.begin();
            specLocItr != arch->namedAddresses.end(); ++specLocItr) 
  {
    //std::string loc_name = specLocItr->second;
    const SpecialMemory *mem = specLocItr->second;
    //uint64_t size = mem->end - mem->begin + 1;
    outs() << "Executor::initializeSpecialGlobals(): Allocating special regiter: " 
           << mem->name << "at [" << mem->base << "-" << mem->base+mem->size << "]\n";
    MemoryObject * mo = memory->allocateFixed(mem->base, mem->size, NULL, true);
    ObjectState *os = bindObjectInState(state, mo, false);

    /* Write fresh symbolics */
    uint64_t w = mem->size*8;
    const Array * array = Array::CreateArray(mem->name + "_arr0", w);
    ref<Expr> fresh_value = Expr::createTempRead(array, w, true);
    ObjectState *wos = state.addressSpace.getWriteable(mo, os);
    wos->write(0, fresh_value);
 
    //os->initializeToZero();
  }



  return;
}



extern void *__dso_handle __attribute__ ((__weak__));

void Executor::initializeGlobals(ExecutionState &state) {
  Module *m = kmodule->module;

  if (m->getModuleInlineAsm() != "")
    klee_warning("executable has module level assembly (ignoring)");
#if LLVM_VERSION_CODE < LLVM_VERSION(3, 3)
  assert(m->lib_begin() == m->lib_end() &&
         "XXX do not support dependent libraries");
#endif
  // represent function globals using the address of the actual llvm function
  // object. given that we use malloc to allocate memory in states this also
  // ensures that we won't conflict. we don't need to allocate a memory object
  // since reading/writing via a function pointer is unsupported anyway.
  outs() << "Executor::initializeGlobals(): initializing function addresses\n";
  for (Module::iterator i = m->begin(), ie = m->end(); i != ie; ++i) {
    Function *f = i;
    ref<ConstantExpr> addr(0);

    outs() << "Executor::initializeGlobals(): considering  function " << f->getName() << "\n";
    // If the symbol has external weak linkage then it is implicitly
    // not defined in this module; if it isn't resolvable then it
    // should be null.
    if (f->hasExternalWeakLinkage() && 
        !externalDispatcher->resolveSymbol(f->getName())) {
      outs() << "Executor::initializeGlobals(): creating NULL pointer\n";
      addr = Expr::createPointer(0);
    } else {

      /// IVAN ADDITIONS BEGIN
      MemoryObject *mo = memory->allocate(arch->pointer_size, false, true, i);
      ObjectState *os = bindObjectInState(state, mo, false);
      /// IVAN ADDITIONS END

      //addr = Expr::createPointer((unsigned long) (void*) f);
      addr = Expr::createPointer(mo->guest_address);
      legalFunctions.insert((uint64_t) (unsigned long) (void*) f);
    }
    
    globalAddresses.insert(std::make_pair(f, addr));
  }

  outs() << "Executor::initializeGlobals(): function addresses initialized\n";

  // Disabled, we don't want to promote use of live externals.
  // IP: does not make sense for MSP430
#if 0 
#ifdef HAVE_CTYPE_EXTERNALS
#ifndef WINDOWS
#ifndef DARWIN
  /* From /usr/include/errno.h: it [errno] is a per-thread variable. */
  int *errno_addr = __errno_location();
  addExternalObject(state, (void *)errno_addr, sizeof *errno_addr, false);

  /* from /usr/include/ctype.h:
       These point into arrays of 384, so they can be indexed by any `unsigned
       char' value [0,255]; by EOF (-1); or by any `signed char' value
       [-128,-1).  ISO C requires that the ctype functions work for `unsigned */
  const uint16_t **addr = __ctype_b_loc();
  addExternalObject(state, const_cast<uint16_t*>(*addr-128),
                    384 * sizeof **addr, true);
  addExternalObject(state, addr, sizeof(*addr), true);
    
  const int32_t **lower_addr = __ctype_tolower_loc();
  addExternalObject(state, const_cast<int32_t*>(*lower_addr-128),
                    384 * sizeof **lower_addr, true);
  addExternalObject(state, lower_addr, sizeof(*lower_addr), true);
  
  const int32_t **upper_addr = __ctype_toupper_loc();
  addExternalObject(state, const_cast<int32_t*>(*upper_addr-128),
                    384 * sizeof **upper_addr, true);
  addExternalObject(state, upper_addr, sizeof(*upper_addr), true);
#endif
#endif
#endif
#endif

  /// IVAN ADDITIONS BEGIN
  /* This allocated flash memory, and peripehral registers */
  outs() << "Executor::initializeGlobals(): initializing special memory\n";
  initializeSpecialGlobals(state);
  outs() << "Executor::initializeGlobals(): special memory initialized\n";
  /// IVAN ADDITIONS END

  // allocate and initialize globals, done in two passes since we may
  // need address of a global in order to initialize some other one.

  // allocate memory objects for all globals
  for (Module::const_global_iterator i = m->global_begin(), e = m->global_end(); i != e; ++i)
  {
    if (i->isDeclaration())
    {
      // FIXME: We have no general way of handling unknown external
      // symbols. If we really cared about making external stuff work
      // better we could support user definition, or use the EXE style
      // hack where we check the object file information.
  
      outs() << "Executor::initializeGlobals(): Allocating stuff for function declaration\n";
      assert(0 && "ALLOCATING MEMORY FOR DECLARATIONS IS NOT SUPPORTED");

      LLVM_TYPE_Q Type *ty = i->getType()->getElementType();
      uint64_t size = kmodule->targetData->getTypeStoreSize(ty);

      // XXX - DWD - hardcode some things until we decide how to fix.
#ifndef WINDOWS
      if (i->getName() == "_ZTVN10__cxxabiv117__class_type_infoE") {
        size = 0x2C;
      } else if (i->getName() == "_ZTVN10__cxxabiv120__si_class_type_infoE") {
        size = 0x2C;
      } else if (i->getName() == "_ZTVN10__cxxabiv121__vmi_class_type_infoE") {
        size = 0x2C;
      }
#endif

      if (size == 0) {
        llvm::errs() << "Unable to find size for global variable: " 
                     << i->getName() 
                     << " (use will result in out of bounds access)\n";
      }

      MemoryObject *mo = memory->allocate(size, false, true, i);
      ObjectState *os = bindObjectInState(state, mo, false);
      globalObjects.insert(std::make_pair(i, mo));
      globalAddresses.insert(std::make_pair(i, mo->getBaseExpr()));

      // Program already running = object already initialized.  Read
      // concrete value and write it to our copy.
      if (size) {
        void *addr;
        if (i->getName() == "__dso_handle") {
          addr = &__dso_handle; // wtf ?
        } else {
          addr = externalDispatcher->resolveSymbol(i->getName());
        }
        if (!addr)
          klee_error("unable to load symbol(%s) while initializing globals.", 
                     i->getName().data());

        for (unsigned offset=0; offset<mo->size; offset++)
          os->write8(offset, ((unsigned char*)addr)[offset]);
      }
    } else 
    {
      LLVM_TYPE_Q Type *ty = i->getType()->getElementType();
      uint64_t size = kmodule->targetData->getTypeStoreSize(ty);

      outs() << "Executor::initializeGlobals(): considering  global " << i->getName() << "\n";
      MemoryObject *mo = memory->allocate(size, false, true, &*i);
      if (!mo)
        llvm::report_fatal_error("out of memory");
      //llvm::outs() << "Executor::initializeGlobals(): allocated memory for global " << i->getName() <<
      //                " and size = " << size << " at address " << mo->address << "\n";
      ObjectState *os = bindObjectInState(state, mo, false);
      globalObjects.insert(std::make_pair(i, mo));
      globalAddresses.insert(std::make_pair(i, mo->getBaseExpr()));

      if (!i->hasInitializer())
          os->initializeToRandom();
    }
  }
  
  // link aliases to their definitions (if bound)
  for (Module::alias_iterator i = m->alias_begin(), ie = m->alias_end(); 
       i != ie; ++i) {
    // Map the alias to its aliasee's address. This works because we have
    // addresses for everything, even undefined functions. 
    globalAddresses.insert(std::make_pair(i, evalConstant(i->getAliasee())));
  }

  // once all objects are allocated, do the actual initialization
  for (Module::const_global_iterator i = m->global_begin(),
         e = m->global_end();
       i != e; ++i) {
    if (i->hasInitializer()) {
      MemoryObject *mo = globalObjects.find(i)->second;
      const ObjectState *os = state.addressSpace.findObject(mo);
      assert(os);
      ObjectState *wos = state.addressSpace.getWriteable(mo, os);
      
      initializeGlobalObject(state, wos, i->getInitializer(), 0);
      // if(i->isConstant()) os->setReadOnly(true);
    }
  }
}

void Executor::branch(ExecutionState &state, 
                      const std::vector< ref<Expr> > &conditions,
                      std::vector<ExecutionState*> &result) {
  TimerStatIncrementer timer(stats::forkTime);
  unsigned N = conditions.size();
  assert(N);

  if (MaxForks!=~0u && stats::forks >= MaxForks) {
    unsigned next = theRNG.getInt32() % N;
    for (unsigned i=0; i<N; ++i) {
      if (i == next) {
        result.push_back(&state);
      } else {
        result.push_back(NULL);
      }
    }
  } else {
    stats::forks += N-1;

    // XXX do proper balance or keep random?
    result.push_back(&state);
    for (unsigned i=1; i<N; ++i) {
      ExecutionState *es = result[theRNG.getInt32() % i];
      ExecutionState *ns = es->branch();
      addedStates.insert(ns);
      result.push_back(ns);
      es->ptreeNode->data = 0;
      std::pair<PTree::Node*,PTree::Node*> res = 
        processTree->split(es->ptreeNode, ns, es);
      ns->ptreeNode = res.first;
      es->ptreeNode = res.second;
    }
  }

  // If necessary redistribute seeds to match conditions, killing
  // states if necessary due to OnlyReplaySeeds (inefficient but
  // simple).
  
  std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
    seedMap.find(&state);
  if (it != seedMap.end()) {
    std::vector<SeedInfo> seeds = it->second;
    seedMap.erase(it);

    // Assume each seed only satisfies one condition (necessarily true
    // when conditions are mutually exclusive and their conjunction is
    // a tautology).
    for (std::vector<SeedInfo>::iterator siit = seeds.begin(), 
           siie = seeds.end(); siit != siie; ++siit) {
      unsigned i;
      for (i=0; i<N; ++i) {
        ref<ConstantExpr> res;
        bool success = 
          solver->getValue(state, siit->assignment.evaluate(conditions[i]), 
                           res);
        assert(success && "FIXME: Unhandled solver failure");
        (void) success;
        if (res->isTrue())
          break;
      }
      
      // If we didn't find a satisfying condition randomly pick one
      // (the seed will be patched).
      if (i==N)
        i = theRNG.getInt32() % N;

      // Extra check in case we're replaying seeds with a max-fork
      if (result[i])
        seedMap[result[i]].push_back(*siit);
    }

    if (OnlyReplaySeeds) {
      for (unsigned i=0; i<N; ++i) {
        if (result[i] && !seedMap.count(result[i])) {
          terminateState(*result[i]);
          result[i] = NULL;
        }
      } 
    }
  }

  for (unsigned i=0; i<N; ++i)
    if (result[i])
      addConstraint(*result[i], conditions[i]);
}

void Executor::branch_connected_summaries(ExecutionState &state,
                           unsigned N, std::vector<ExecutionState*> &result)
{
  TimerStatIncrementer timer(stats::forkTime);
  assert(N);

  stats::forks += N-1;

  // XXX do proper balance or keep random?
  result.push_back(&state);
  for (unsigned i=1; i<N; ++i)
  {
    ExecutionState *es = result[theRNG.getInt32() % i];
    ExecutionState *ns = es->branch();
    addedStates.insert(ns);
    result.push_back(ns);
    es->ptreeNode->data = 0;
    std::pair<PTree::Node*,PTree::Node*> res = 
      processTree->split(es->ptreeNode, ns, es);
    ns->ptreeNode = res.first;
    es->ptreeNode = res.second;
  }
  return;
}

Executor::StatePair 
Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
  Solver::Validity res;
  std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
    seedMap.find(&current);
  bool isSeeding = it != seedMap.end();

  if (!isSeeding && !isa<ConstantExpr>(condition) && 
      (MaxStaticForkPct!=1. || MaxStaticSolvePct != 1. ||
       MaxStaticCPForkPct!=1. || MaxStaticCPSolvePct != 1.) &&
      statsTracker->elapsed() > 60.) {
    StatisticManager &sm = *theStatisticManager;
    CallPathNode *cpn = current.stack.back().callPathNode;
    if ((MaxStaticForkPct<1. &&
         sm.getIndexedValue(stats::forks, sm.getIndex()) > 
         stats::forks*MaxStaticForkPct) ||
        (MaxStaticCPForkPct<1. &&
         cpn && (cpn->statistics.getValue(stats::forks) > 
                 stats::forks*MaxStaticCPForkPct)) ||
        (MaxStaticSolvePct<1 &&
         sm.getIndexedValue(stats::solverTime, sm.getIndex()) > 
         stats::solverTime*MaxStaticSolvePct) ||
        (MaxStaticCPForkPct<1. &&
         cpn && (cpn->statistics.getValue(stats::solverTime) > 
                 stats::solverTime*MaxStaticCPSolvePct))) {
      ref<ConstantExpr> value; 
      outs() << "IVAN: Going to execute solver->getValue() at line " << __LINE__ << "\n";
      bool success = solver->getValue(current, condition, value);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      addConstraint(current, EqExpr::create(value, condition));
      condition = value;
    } else
        outs() << "IVAN: Not going to execute solver->getValue() at line " << 728 << "\n";
  } else
      outs() << "IVAN: Not going to execute solver->getValue() at line " << 728 << "\n";

  double timeout = coreSolverTimeout;
  if (isSeeding)
    timeout *= it->second.size();
  solver->setTimeout(timeout);
  bool success = solver->evaluate(current, condition, res);
  solver->setTimeout(0);
  if (!success) {
    current.pc = current.prevPC;
    terminateStateEarly(current, "Query timed out (fork).");
    return StatePair(0, 0);
  }

  if (!isSeeding) {
    if (replayPath && !isInternal) {
      assert(replayPosition<replayPath->size() &&
             "ran out of branches in replay path mode");
      bool branch = (*replayPath)[replayPosition++];
      
      if (res==Solver::True) {
        assert(branch && "hit invalid branch in replay path mode");
      } else if (res==Solver::False) {
        assert(!branch && "hit invalid branch in replay path mode");
      } else {
        // add constraints
        if(branch) {
          res = Solver::True;
          addConstraint(current, condition);
        } else  {
          res = Solver::False;
          addConstraint(current, Expr::createIsZero(condition));
        }
      }
    } else if (res==Solver::Unknown) {
      assert(!replayOut && "in replay mode, only one branch can be true.");
      
      if ((MaxMemoryInhibit && atMemoryLimit) || 
          current.forkDisabled ||
          inhibitForking || 
          (MaxForks!=~0u && stats::forks >= MaxForks)) {

	if (MaxMemoryInhibit && atMemoryLimit)
	  klee_warning_once(0, "skipping fork (memory cap exceeded)");
	else if (current.forkDisabled)
	  klee_warning_once(0, "skipping fork (fork disabled on current path)");
	else if (inhibitForking)
	  klee_warning_once(0, "skipping fork (fork disabled globally)");
	else 
	  klee_warning_once(0, "skipping fork (max-forks reached)");

        TimerStatIncrementer timer(stats::forkTime);
        if (theRNG.getBool()) {
          addConstraint(current, condition);
          res = Solver::True;        
        } else {
          addConstraint(current, Expr::createIsZero(condition));
          res = Solver::False;
        }
      }
    }
  }

  // Fix branch in only-replay-seed mode, if we don't have both true
  // and false seeds.
  if (isSeeding && 
      (current.forkDisabled || OnlyReplaySeeds) && 
      res == Solver::Unknown) {
    bool trueSeed=false, falseSeed=false;
    // Is seed extension still ok here?
    for (std::vector<SeedInfo>::iterator siit = it->second.begin(), 
           siie = it->second.end(); siit != siie; ++siit) {
      ref<ConstantExpr> res;
      bool success = 
        solver->getValue(current, siit->assignment.evaluate(condition), res);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      if (res->isTrue()) {
        trueSeed = true;
      } else {
        falseSeed = true;
      }
      if (trueSeed && falseSeed)
        break;
    }
    if (!(trueSeed && falseSeed)) {
      assert(trueSeed || falseSeed);
      
      res = trueSeed ? Solver::True : Solver::False;
      addConstraint(current, trueSeed ? condition : Expr::createIsZero(condition));
    }
  }


  // XXX - even if the constraint is provable one way or the other we
  // can probably benefit by adding this constraint and allowing it to
  // reduce the other constraints. For example, if we do a binary
  // search on a particular value, and then see a comparison against
  // the value it has been fixed at, we should take this as a nice
  // hint to just use the single constraint instead of all the binary
  // search ones. If that makes sense.
    ///IVAN ADDITIONS BEGIN
                  KInstruction *ki = current.prevPC;
                  Instruction *instr = ki->inst;
                  std::string instr_str;
                  raw_string_ostream str_stream(instr_str);                                 
                  str_stream << *instr;
    ///IVAN ADDITIONS END
  if (res==Solver::True) {
    if (!isInternal) {
      if (pathWriter) {
        current.pathOS << "1";
      }
    }

    current.path_choices.push_back(1);
                  //current.path_choices_debug.push_back(instr_str);
    return StatePair(&current, 0);
  } else if (res==Solver::False) {
    if (!isInternal) {
      if (pathWriter) {
        current.pathOS << "0";
      }
    }

    current.path_choices.push_back(0);
                  //current.path_choices_debug.push_back(instr_str);
    return StatePair(0, &current);
  } else {
    TimerStatIncrementer timer(stats::forkTime);
    ExecutionState *falseState, *trueState = &current;

    ++stats::forks;

    falseState = trueState->branch();
    addedStates.insert(falseState);

    if (RandomizeFork && theRNG.getBool())
      std::swap(trueState, falseState);

    if (it != seedMap.end()) {
      std::vector<SeedInfo> seeds = it->second;
      it->second.clear();
      std::vector<SeedInfo> &trueSeeds = seedMap[trueState];
      std::vector<SeedInfo> &falseSeeds = seedMap[falseState];
      for (std::vector<SeedInfo>::iterator siit = seeds.begin(), 
             siie = seeds.end(); siit != siie; ++siit) {
        ref<ConstantExpr> res;
        bool success = 
          solver->getValue(current, siit->assignment.evaluate(condition), res);
        assert(success && "FIXME: Unhandled solver failure");
        (void) success;
        if (res->isTrue()) {
          trueSeeds.push_back(*siit);
        } else {
          falseSeeds.push_back(*siit);
        }
      }
      
      bool swapInfo = false;
      if (trueSeeds.empty()) {
        if (&current == trueState) swapInfo = true;
        seedMap.erase(trueState);
      }
      if (falseSeeds.empty()) {
        if (&current == falseState) swapInfo = true;
        seedMap.erase(falseState);
      }
      if (swapInfo) {
        std::swap(trueState->coveredNew, falseState->coveredNew);
        std::swap(trueState->coveredLines, falseState->coveredLines);
      }
    }

    current.ptreeNode->data = 0;
    std::pair<PTree::Node*, PTree::Node*> res =
      processTree->split(current.ptreeNode, falseState, trueState);
    falseState->ptreeNode = res.first;
    trueState->ptreeNode = res.second;

    if (!isInternal) {
      if (pathWriter) {
        falseState->pathOS = pathWriter->open(current.pathOS);
        trueState->pathOS << "1";
        falseState->pathOS << "0";
        //llvm::outs() << "MAKAAAAAKKKA\n";
      }      
      if (symPathWriter) {
        falseState->symPathOS = symPathWriter->open(current.symPathOS);
        trueState->symPathOS << "1";
        falseState->symPathOS << "0";
      }
    }

    ///IVAN ADDITIONS BEGIN
    trueState->path_choices.push_back(1);
    falseState->path_choices.push_back(0);
                  //trueState->path_choices_debug.push_back(instr_str);
                  //falseState->path_choices_debug.push_back(instr_str);
    ///IVAN ADDITIONS END
    
    addConstraint(*trueState, condition);
    addConstraint(*falseState, Expr::createIsZero(condition));

    // Kinda gross, do we even really still want this option?
    if (MaxDepth && MaxDepth<=trueState->depth) {
      terminateStateEarly(*trueState, "max-depth exceeded.");
      terminateStateEarly(*falseState, "max-depth exceeded.");
      return StatePair(0, 0);
    }

    return StatePair(trueState, falseState);
  }
}

void Executor::addConstraint(ExecutionState &state, ref<Expr> condition) {
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(condition)) {
    if (!CE->isTrue())
      llvm::report_fatal_error("attempt to add invalid constraint");
    return;
  }

  // Check to see if this constraint violates seeds.
  std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
    seedMap.find(&state);
  if (it != seedMap.end()) {
    bool warn = false;
    for (std::vector<SeedInfo>::iterator siit = it->second.begin(), 
           siie = it->second.end(); siit != siie; ++siit) {
      bool res;
      bool success = 
        solver->mustBeFalse(state, siit->assignment.evaluate(condition), res);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      if (res) {
        siit->patchSeed(state, condition, solver);
        warn = true;
      }
    }
    if (warn)
      klee_warning("seeds patched for violating constraint"); 
  }

  state.addConstraint(condition);
  /// IVAN ADDITIONS BEGIN
  StackFrame &sf = state.stack.back();
  sf.num_of_constraints++;
  /// IVAN ADDITIONS END
  if (ivcEnabled)
    doImpliedValueConcretization(state, condition, 
                                 ConstantExpr::alloc(1, Expr::Bool));
}

ref<klee::ConstantExpr> Executor::evalConstant(const Constant *c) {
  if (const llvm::ConstantExpr *ce = dyn_cast<llvm::ConstantExpr>(c)) {
    return evalConstantExpr(ce);
  } else {
    if (const ConstantInt *ci = dyn_cast<ConstantInt>(c)) {
      return ConstantExpr::alloc(ci->getValue());
    } else if (const ConstantFP *cf = dyn_cast<ConstantFP>(c)) {      
      return ConstantExpr::alloc(cf->getValueAPF().bitcastToAPInt());
    } else if (const GlobalValue *gv = dyn_cast<GlobalValue>(c)) {
      return globalAddresses.find(gv)->second;
    } else if (isa<ConstantPointerNull>(c)) {
      return Expr::createPointer(0);
    } else if (isa<UndefValue>(c) || isa<ConstantAggregateZero>(c)) {
      return ConstantExpr::create(0, getWidthForLLVMType(c->getType()));
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 1)
    } else if (const ConstantDataSequential *cds =
                 dyn_cast<ConstantDataSequential>(c)) {
      std::vector<ref<Expr> > kids;
      for (unsigned i = 0, e = cds->getNumElements(); i != e; ++i) {
        ref<Expr> kid = evalConstant(cds->getElementAsConstant(i));
        kids.push_back(kid);
      }
      ref<Expr> res = ConcatExpr::createN(kids.size(), kids.data());
      return cast<ConstantExpr>(res);
#endif
    } else if (const ConstantStruct *cs = dyn_cast<ConstantStruct>(c)) {
      const StructLayout *sl = kmodule->targetData->getStructLayout(cs->getType());
      llvm::SmallVector<ref<Expr>, 4> kids;
      for (unsigned i = cs->getNumOperands(); i != 0; --i) {
        unsigned op = i-1;
        ref<Expr> kid = evalConstant(cs->getOperand(op));

        uint64_t thisOffset = sl->getElementOffsetInBits(op),
                 nextOffset = (op == cs->getNumOperands() - 1)
                              ? sl->getSizeInBits()
                              : sl->getElementOffsetInBits(op+1);
        if (nextOffset-thisOffset > kid->getWidth()) {
          uint64_t paddingWidth = nextOffset-thisOffset-kid->getWidth();
          kids.push_back(ConstantExpr::create(0, paddingWidth));
        }

        kids.push_back(kid);
      }
      ref<Expr> res = ConcatExpr::createN(kids.size(), kids.data());
      return cast<ConstantExpr>(res);
    } else if (const ConstantArray *ca = dyn_cast<ConstantArray>(c)){
      llvm::SmallVector<ref<Expr>, 4> kids;
      for (unsigned i = ca->getNumOperands(); i != 0; --i) {
        unsigned op = i-1;
        ref<Expr> kid = evalConstant(ca->getOperand(op));
        kids.push_back(kid);
      }
      ref<Expr> res = ConcatExpr::createN(kids.size(), kids.data());
      return cast<ConstantExpr>(res);
    } else {
      // Constant{Vector}
      llvm::report_fatal_error("invalid argument to evalConstant()");
    }
  }
}

const Cell& Executor::eval(KInstruction *ki, unsigned index, 
                           ExecutionState &state) const {
  assert(index < ki->inst->getNumOperands());
  int vnumber = ki->operands[index];

  assert(vnumber != -1 &&
         "Invalid operand to eval(), not a value or constant!");

  // Determine if this is a constant or not.
  if (vnumber < 0) {
    unsigned index = -vnumber - 2;
    return kmodule->constantTable[index];
  } else {
    unsigned index = vnumber;
    StackFrame &sf = state.stack.back();
    //llvm::outs() << "Executor::eval() : returning from sf.locals\n";
    return sf.locals[index];
  }
}

void Executor::bindLocal(KInstruction *target, ExecutionState &state, 
                         ref<Expr> value) {
  getDestCell(state, target).value = value;
}

void Executor::bindArgument(KFunction *kf, unsigned index, 
                            ExecutionState &state, ref<Expr> value) {
  getArgumentCell(state, kf, index).value = value;
}

ref<Expr> Executor::toUnique(const ExecutionState &state, 
                             ref<Expr> &e) {
  ref<Expr> result = e;

  if (!isa<ConstantExpr>(e)) {
    ref<ConstantExpr> value;
    bool isTrue = false;

    solver->setTimeout(coreSolverTimeout);      
    if (solver->getValue(state, e, value) &&
        solver->mustBeTrue(state, EqExpr::create(e, value), isTrue) &&
        isTrue)
      result = value;
    solver->setTimeout(0);
  }
  
  return result;
}


/* Concretize the given expression, and return a possible constant value. 
   'reason' is just a documentation string stating the reason for concretization. */
ref<klee::ConstantExpr> 
Executor::toConstant(ExecutionState &state, 
                     ref<Expr> e,
                     const char *reason) {
  e = state.constraints.simplifyExpr(e);
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(e))
    return CE;

  ref<ConstantExpr> value;
  bool success = solver->getValue(state, e, value);
  assert(success && "FIXME: Unhandled solver failure");
  (void) success;

  std::string str;
  llvm::raw_string_ostream os(str);
  os << "silently concretizing (reason: " << reason << ") expression " << e
     << " to value " << value << " (" << (*(state.pc)).info->file << ":"
     << (*(state.pc)).info->line << ")";

  if (AllExternalWarnings)
    klee_warning(reason, os.str().c_str());
  else
    klee_warning_once(reason, "%s", os.str().c_str());

  addConstraint(state, EqExpr::create(e, value));
    
  return value;
}

void Executor::executeGetValue(ExecutionState &state,
                               ref<Expr> e,
                               KInstruction *target) {
  e = state.constraints.simplifyExpr(e);
  std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
    seedMap.find(&state);
  if (it==seedMap.end() || isa<ConstantExpr>(e)) {
    ref<ConstantExpr> value;
    bool success = solver->getValue(state, e, value);
    assert(success && "FIXME: Unhandled solver failure");
    (void) success;
    bindLocal(target, state, value);
  } else {
    std::set< ref<Expr> > values;
    for (std::vector<SeedInfo>::iterator siit = it->second.begin(), 
           siie = it->second.end(); siit != siie; ++siit) {
      ref<ConstantExpr> value;
      bool success = 
        solver->getValue(state, siit->assignment.evaluate(e), value);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      values.insert(value);
    }
    
    std::vector< ref<Expr> > conditions;
    for (std::set< ref<Expr> >::iterator vit = values.begin(), 
           vie = values.end(); vit != vie; ++vit)
      conditions.push_back(EqExpr::create(e, *vit));

    std::vector<ExecutionState*> branches;
    branch(state, conditions, branches);
    
    std::vector<ExecutionState*>::iterator bit = branches.begin();
    for (std::set< ref<Expr> >::iterator vit = values.begin(), 
           vie = values.end(); vit != vie; ++vit) {
      ExecutionState *es = *bit;
      if (es)
        bindLocal(target, *es, *vit);
      ++bit;
    }
  }
}

void Executor::stepInstruction(ExecutionState &state) {
  if (DebugPrintInstructions) {
    printFileLine(state, state.pc);
    llvm::errs().indent(10) << stats::instructions << " ";
    llvm::errs() << *(state.pc->inst) << '\n';
  }

  if (statsTracker)
    statsTracker->stepInstruction(state);

  ++stats::instructions;
  state.prevPC = state.pc;
  ++state.pc;

  if (stats::instructions==StopAfterNInstructions)
    haltExecution = true;
}

void Executor::executeCall(ExecutionState &state, 
                           KInstruction *ki,
                           Function *f,
                           std::vector< ref<Expr> > &arguments) {
  Instruction *i = ki->inst;
  if (f && f->isDeclaration()) {
    //llvm::outs() << "DEBUG: function call to declaration\n";
    switch(f->getIntrinsicID()) {
    case Intrinsic::not_intrinsic:
      //llvm::outs() << "DEBUG: function is not intrinsic\n";
      // state may be destroyed by this call, cannot touch
      callExternalFunction(state, ki, f, arguments);
      break;
        
      // va_arg is handled by caller and intrinsic lowering, see comment for
      // ExecutionState::varargs
    case Intrinsic::vastart:  {
      StackFrame &sf = state.stack.back();
      assert(sf.varargs && 
             "vastart called in function with no vararg object");

      // FIXME: This is really specific to the architecture, not the pointer
      // size. This happens to work fir x86-32 and x86-64, however.
      Expr::Width WordSize = Context::get().getPointerWidth();
      if (WordSize == Expr::Int32) {
        executeMemoryOperation(state, true, arguments[0], 
                               sf.varargs->getBaseExpr(), 0);
      } else {
        assert(WordSize == Expr::Int64 && "Unknown word size!");

        // X86-64 has quite complicated calling convention. However,
        // instead of implementing it, we can do a simple hack: just
        // make a function believe that all varargs are on stack.
        executeMemoryOperation(state, true, arguments[0],
                               ConstantExpr::create(48, 32), 0); // gp_offset
        executeMemoryOperation(state, true,
                               AddExpr::create(arguments[0], 
                                               ConstantExpr::create(4, 64)),
                               ConstantExpr::create(304, 32), 0); // fp_offset
        executeMemoryOperation(state, true,
                               AddExpr::create(arguments[0], 
                                               ConstantExpr::create(8, 64)),
                               sf.varargs->getBaseExpr(), 0); // overflow_arg_area
        executeMemoryOperation(state, true,
                               AddExpr::create(arguments[0], 
                                               ConstantExpr::create(16, 64)),
                               ConstantExpr::create(0, 64), 0); // reg_save_area
      }
      break;
    }
    case Intrinsic::vaend:
      // va_end is a noop for the interpreter.
      //
      // FIXME: We should validate that the target didn't do something bad
      // with vaeend, however (like call it twice).
      break;
        
    case Intrinsic::vacopy:
      // va_copy should have been lowered.
      //
      // FIXME: It would be nice to check for errors in the usage of this as
      // well.
    default:
      klee_error("unknown intrinsic: %s", f->getName().data());
    }

    if (InvokeInst *ii = dyn_cast<InvokeInst>(i))
      transferToBasicBlock(ii->getNormalDest(), i->getParent(), state);
  } else {
    // FIXME: I'm not really happy about this reliance on prevPC but it is ok, I
    // guess. This just done to avoid having to pass KInstIterator everywhere
    // instead of the actual instruction, since we can't make a KInstIterator
    // from just an instruction (unlike LLVM).
    KFunction *kf = kmodule->functionMap[f];
    state.pushFrame(state.prevPC, kf);
    /// IVAN ADDITIONS BEGIN
    state.stack.back().cur_fsummary = state.cur_fsummary; // this will set the summary of the function which we are going to invoke
    /// IVAN ADDITIONS END
    state.pc = kf->instructions;
        
    if (statsTracker)
      statsTracker->framePushed(state, &state.stack[state.stack.size()-2]);
 
     // TODO: support "byval" parameter attribute
     // TODO: support zeroext, signext, sret attributes
        
    unsigned callingArgs = arguments.size();
    unsigned funcArgs = f->arg_size();
    if (!f->isVarArg()) {
      if (callingArgs > funcArgs) {
        klee_warning_once(f, "calling %s with extra arguments.", 
                          f->getName().data());
      } else if (callingArgs < funcArgs) {
        terminateStateOnError(state, "calling function with too few arguments", 
                              "user.err");
        return;
      }
    } else {
      Expr::Width WordSize = Context::get().getPointerWidth();

      if (callingArgs < funcArgs) {
        terminateStateOnError(state, "calling function with too few arguments", 
                              "user.err");
        return;
      }
            
      StackFrame &sf = state.stack.back();
      unsigned size = 0;
      for (unsigned i = funcArgs; i < callingArgs; i++) {
        // FIXME: This is really specific to the architecture, not the pointer
        // size. This happens to work fir x86-32 and x86-64, however.
        if (WordSize == Expr::Int32) {
          size += Expr::getMinBytesForWidth(arguments[i]->getWidth());
        } else {
          Expr::Width argWidth = arguments[i]->getWidth();
          // AMD64-ABI 3.5.7p5: Step 7. Align l->overflow_arg_area upwards to a 16
          // byte boundary if alignment needed by type exceeds 8 byte boundary.
          //
          // Alignment requirements for scalar types is the same as their size
          if (argWidth > Expr::Int64) {
             size = llvm::RoundUpToAlignment(size, 16);
          }
          size += llvm::RoundUpToAlignment(argWidth, WordSize) / 8;
        }
      }

      MemoryObject *mo = sf.varargs = memory->allocate(size, true, false, 
                                                       state.prevPC->inst);
      if (!mo) {
        terminateStateOnExecError(state, "out of memory (varargs)");
        return;
      }

      if ((WordSize == Expr::Int64) && (mo->guest_address & 15)) {
        // Both 64bit Linux/Glibc and 64bit MacOSX should align to 16 bytes.
        klee_warning_once(0, "While allocating varargs: malloc did not align to 16 bytes.");
      }

      ObjectState *os = bindObjectInState(state, mo, true);
      unsigned offset = 0;
      for (unsigned i = funcArgs; i < callingArgs; i++) {
        // FIXME: This is really specific to the architecture, not the pointer
        // size. This happens to work fir x86-32 and x86-64, however.
        if (WordSize == Expr::Int32) {
          os->write(offset, arguments[i]);
          offset += Expr::getMinBytesForWidth(arguments[i]->getWidth());
        } else {
          assert(WordSize == Expr::Int64 && "Unknown word size!");

          Expr::Width argWidth = arguments[i]->getWidth();
          if (argWidth > Expr::Int64) {
             offset = llvm::RoundUpToAlignment(offset, 16);
          }
          os->write(offset, arguments[i]);
          offset += llvm::RoundUpToAlignment(argWidth, WordSize) / 8;
        }
      }
    }

    unsigned numFormals = f->arg_size();
    for (unsigned i=0; i<numFormals; ++i) 
      bindArgument(kf, i, state, arguments[i]);
  }
}

void Executor::transferToBasicBlock(BasicBlock *dst, BasicBlock *src, 
                                    ExecutionState &state) {
  // Note that in general phi nodes can reuse phi values from the same
  // block but the incoming value is the eval() result *before* the
  // execution of any phi nodes. this is pathological and doesn't
  // really seem to occur, but just in case we run the PhiCleanerPass
  // which makes sure this cannot happen and so it is safe to just
  // eval things in order. The PhiCleanerPass also makes sure that all
  // incoming blocks have the same order for each PHINode so we only
  // have to compute the index once.
  //
  // With that done we simply set an index in the state so that PHI
  // instructions know which argument to eval, set the pc, and continue.
  
  // XXX this lookup has to go ?
  KFunction *kf = state.stack.back().kf;
  unsigned entry = kf->basicBlockEntry[dst];
  state.pc = &kf->instructions[entry];
  if (state.pc->inst->getOpcode() == Instruction::PHI) {
    PHINode *first = static_cast<PHINode*>(state.pc->inst);
    state.incomingBBIndex = first->getBasicBlockIndex(src);
  }
}

void Executor::printFileLine(ExecutionState &state, KInstruction *ki) {
  const InstructionInfo &ii = *ki->info;
  if (ii.file != "")
    llvm::errs() << "     " << ii.file << ":" << ii.line << ":";
  else
    llvm::errs() << "     [no debug info]:";
}

/// Compute the true target of a function call, resolving LLVM and KLEE aliases
/// and bitcasts.
Function* Executor::getTargetFunction(Value *calledVal, ExecutionState &state) {
  SmallPtrSet<const GlobalValue*, 3> Visited;

  Constant *c = dyn_cast<Constant>(calledVal);
  if (!c)
    return 0;

  while (true) {
    if (GlobalValue *gv = dyn_cast<GlobalValue>(c)) {
      if (!Visited.insert(gv))
        return 0;

      std::string alias = state.getFnAlias(gv->getName());
      if (alias != "") {
        llvm::Module* currModule = kmodule->module;
        GlobalValue *old_gv = gv;
        gv = currModule->getNamedValue(alias);
        if (!gv) {
          llvm::errs() << "Function " << alias << "(), alias for " 
                       << old_gv->getName() << " not found!\n";
          assert(0 && "function alias not found");
        }
      }
     
      if (Function *f = dyn_cast<Function>(gv))
        return f;
      else if (GlobalAlias *ga = dyn_cast<GlobalAlias>(gv))
        c = ga->getAliasee();
      else
        return 0;
    } else if (llvm::ConstantExpr *ce = dyn_cast<llvm::ConstantExpr>(c)) {
      if (ce->getOpcode()==Instruction::BitCast)
        c = ce->getOperand(0);
      else
        return 0;
    } else
      return 0;
  }
}

/// TODO remove?
static bool isDebugIntrinsic(const Function *f, KModule *KM) {
  return false;
}

static inline const llvm::fltSemantics * fpWidthToSemantics(unsigned width) {
  switch(width) {
  case Expr::Int32:
    return &llvm::APFloat::IEEEsingle;
  case Expr::Int64:
    return &llvm::APFloat::IEEEdouble;
  case Expr::Fl80:
    return &llvm::APFloat::x87DoubleExtended;
  default:
    return 0;
  }
}

//void Executor::scan2_backup(const ref<Expr> &e) {
//  const ConstantExpr *ce = dyn_cast<ConstantExpr>(e);
//  if (!ce)
//  {
//    Expr *ep = e.get();
//    llvm::outs() << "Considering kids of " << *ep << " (type = " << e->getKind() << ", @" << ep << ")\n";
//    for (unsigned i=0; i<ep->getNumKids(); i++)
//      scan2(ep->getKid(i));
//    llvm::outs() << "End of kids\n";
//
//    if (const ReadExpr *re = dyn_cast<ReadExpr>(e)) {
//      llvm::outs() << "Found a Read expression: " << *re << " (type = " << e->getKind() << ", @" << re << ")\n";
//      llvm::outs() << "The corresponding array: " << re->updates.root->getName() << ", @" <<  re->updates.root << "\n";
//    } else
//    if (const ConcatExpr *ce = dyn_cast<ConcatExpr>(e)) 
//    {
//      llvm::outs() << "Found a Concat expression: " << *ep << " (type = " << e->getKind() << ", @" << ep << ")\n";
//      llvm::outs() << call_symbolic_replacements.count(ep) << "\n";
//    } else
//      llvm::outs() << "Found another expression: " << *ep << " (type = " << e->getKind() << ", @" << ep << ")\n";
//
//  } else 
//  {
//    llvm::outs() << "Found a Constant expression: " << *ce << " (type = " << e->getKind() << ", @" << ce << ")\n";
//  }
//}


/* Extract all ConcatExpr which are concatenations of two reads from e.
 *
 * Recursivealy consider all kids of e, returning a kid if it is a concat 
 * exprssion of two reads.
 *
 * @param e Exprssion to extract concats from
 * @return Vector of all found concat expressions
 */
//std::vector<const ConcatExpr *> Executor::extract_concat_subexpressions(ref<Expr> e)
//std::vector<ref<Expr> > Executor::extract_concat_subexpressions(ref<Expr> e)
//{
//  std::vector<ref<Expr> > res;
//
//  const ConstantExpr *ce = dyn_cast<ConstantExpr>(e);
//  if (!ce)
//  {
//    Expr *ep = e.get();
//
//    if (const ConcatExpr *ce = dyn_cast<ConcatExpr>(e)) 
//    {
//      //llvm::outs() << "Executor::extract_concat_subexpressions(): Found a concat expression: " << *ce << "\n";
//      res.push_back(e);
//    }
//
//    for (unsigned i=0; i<ep->getNumKids(); i++)
//    {
//      std::vector<ref<Expr> > sub_res;
//      sub_res = extract_concat_subexpressions(ep->getKid(i));
//      res.insert(res.end(), sub_res.begin(), sub_res.end());
//    }
//  }
//  return res;
//}

std::vector<ref<Expr> > extract_concat_subexpressions(ref<Expr> e)
{
  std::vector<ref<Expr> > res;

  const klee::ConstantExpr *ce = dyn_cast<klee::ConstantExpr>(e);
  if (!ce)
  {
    Expr *ep = e.get();

    if (const klee::ConcatExpr *ce = dyn_cast<klee::ConcatExpr>(e)) 
    {
      //llvm::outs() << "Executor::extract_concat_subexpressions(): Found a concat expression: " << *ce << "\n";
      res.push_back(e);
    }

    for (unsigned i=0; i<ep->getNumKids(); i++)
    {
      std::vector<ref<Expr> > sub_res;
      sub_res = extract_concat_subexpressions(ep->getKid(i));
      res.insert(res.end(), sub_res.begin(), sub_res.end());
    }
  }
  return res;
}



/* Find the an fsummary of the next callpath function we can glue with
 *
 * Given the current function summary (which should be a summary of a
 * function that belong to the callpath) returns a function summary for
 * the next function in the call graph with which we can glue
 *
 * @param cur_psmmary Function summary for <cur_func> which we are using now
 * @param cur_func Function which we are executing now
 * @return Functon summary of the next func along the call path
 * */
path_summary_ty* Executor::find_next_callgraph_psummary(path_summary_ty *cur_psmmary, llvm::Function *cur_func)
{

  /* First find the next function along the callgraph */
  llvm::Function *next_func = NULL;
  for(FVector::iterator it = call_path.begin(); it != call_path.end(); ++it)
  {
    if(cur_func == (*it))
    {
      ++it;
      next_func = (llvm::Function *)(*it);
      break;
    }
  }
  assert(next_func && "next_func is NULL");
  llvm::outs() << "Executor::find_next_callgraph_psummary(): cur_func = " << cur_func->getName() << "\n";
  llvm::outs() << "Executor::find_next_callgraph_psummary(): next_func = " << next_func->getName() << "\n";
  llvm::outs() << "Executor::find_next_callgraph_psummary(): last_func = " << call_path[call_path.size()-1]->getName() << "\n";

  /* Second, find summary of the next function that can glue with current summary */
  std::vector<path_summary_ty *> &next_func_smmries = good_path_summaries[next_func];
  for(std::vector<path_summary_ty *>::iterator it = next_func_smmries.begin(); it != next_func_smmries.end(); ++it)
  {
    path_summary_ty *next_func_smmary = *it;
    if(comp_symbex_can_glue1(*cur_psmmary, *next_func_smmary))
      return next_func_smmary;
  }
  return NULL;
}

/* The current stack frame keeps the seq_number of the call symbolics */
/* The call symbolics are in the
 * current_state->cur_path_summary->call_symbolic_replacements */
InnerCall* Executor::get_InnerCall_by_seqnum(path_summary_ty *smmry, unsigned seqnum)
{
  InnerCall *res = NULL;
  for(call_symbolic_replacements_ty::iterator it  = smmry->call_symbolic_replacements.begin();
                                              it != smmry->call_symbolic_replacements.end();
                                              ++it)
  {
    InnerCall *inner_call = it->second;
    llvm::outs() << "Executor::get_InnerCall_by_seqnum(): Considering suppl call" << *(inner_call->call_inst) <<
                      " with seq num =  " << inner_call->seq_num << "\n";
    if(seqnum == inner_call->seq_num)
      return inner_call;
  }
  return NULL;
}


bool Executor::is_part_of_callpath(llvm::Function *f)
{
  FVector::iterator it;
  it = find(call_path.begin(), call_path.end(), f);
  if (it != call_path.end())
    return true;
  else
    return false;
}


///* Replace all concat expressions in <conditions> with <retvalue> */
//void Executor::comp_symbex_replace_for_retvalue(ref<Expr> &condition, ref<Expr> &retvalue)
//{
//  //assert(isa<ConstantExpr>(retvalue) && "Function return value is not a constant expression");
//
//  if (!isa<ConstantExpr>(condition))
//  {
//    //Expr *ep = condition.get();
//
//    /* If it is something like [Eq false (Eq 2 (ReadLSB w32 0 arg_printGesture_1))] */
//    if (BinaryExpr *be = dyn_cast<BinaryExpr>(condition)) 
//    {
//      //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue(): parsing binary expression:\n" << *be << "\n";
//      if(isa<ConcatExpr>(be->left) && isa<ConcatExpr>(be->right))
//      {
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue(): both are concats\n";
//        ref<Expr> arr[2];
//        arr[0] = retvalue;
//        arr[1] = retvalue;
//        //be->rebuild(arr);
//        ref<Expr> tmp = be->rebuild(arr);
//        condition = tmp.get();
//      }
//
//      if(isa<ConcatExpr>(be->left) && !isa<ConcatExpr>(be->right))
//      {
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue(): left is a concat\n";
//        ref<Expr> arr[2];
//        arr[0] = retvalue;
//        arr[1] = be->right;
//        ref<Expr> tmp = be->rebuild(arr);
//        condition = tmp.get();
//        //be = dyn_cast<BinaryExpr>(be->rebuild(arr));
//        comp_symbex_replace_for_retvalue(be->right, retvalue);
//      }
//      if(!isa<ConcatExpr>(be->left) && isa<ConcatExpr>(be->right))
//      {
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue(): right is a concat\n";
//        ref<Expr> arr[2];
//        arr[0] = be->left;
//        arr[1] = retvalue;
//        ref<Expr> tmp = be->rebuild(arr);
//        condition = tmp.get();
//
//        //be->rebuild(arr);
//        comp_symbex_replace_for_retvalue(be->left, retvalue);
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue():  after rebuild:\n" << tmp << "\n";
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue():  after rebuild:\n" << be << "\n";
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue():  after rebuild:\n" << condition << "\n";
//      }
//      if(!isa<ConcatExpr>(be->left) && !isa<ConcatExpr>(be->right))
//      {
//        //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue(): non is a concat\n";
//        comp_symbex_replace_for_retvalue(be->left, retvalue);
//        comp_symbex_replace_for_retvalue(be->right, retvalue);
//      }
//    }
//
//    /* If it is something like [Select w32 (Eq 4 (ReadLSB w32 0 arg_printGesture_1)) 9 4] */
//    else if (SelectExpr *se = dyn_cast<SelectExpr>(condition)) 
//    {
//      //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue():  considerting select:\n" << *se << "\n";
//      ref<Expr> arr[3];
//      if(isa<ConcatExpr>(se->cond))
//        arr[0] = retvalue;
//      else
//        arr[0] = se->cond;
//
//      if(isa<ConcatExpr>(se->trueExpr))
//        arr[1] = retvalue;
//      else
//        arr[1] = se->trueExpr;
//
//      if(isa<ConcatExpr>(se->falseExpr))
//        arr[2] = retvalue;
//      else
//        arr[2] = se->falseExpr;
//
//      ref<Expr> tmp = se->rebuild(arr);
//      condition = tmp.get();
//
//      if(!isa<ConcatExpr>(se->cond))
//        comp_symbex_replace_for_retvalue(se->cond, retvalue);
//
//      if(!isa<ConcatExpr>(se->trueExpr))
//        comp_symbex_replace_for_retvalue(se->trueExpr, retvalue);
//
//      if(!isa<ConcatExpr>(se->falseExpr))
//        comp_symbex_replace_for_retvalue(se->falseExpr, retvalue);
//    }
//  }
//  return;
//}

/* Replace all concat expressions in <conditions> with <retvalue> */
ref<Expr> Executor::comp_symbex_replace_for_retvalue(ref<Expr> expr, ref<Expr> &retvalue)
{
  if (isa<ConstantExpr>(expr))
    return expr;

  /* If it is something like [Eq false (Eq 2 (ReadLSB w32 0 arg_printGesture_1))] */
  if (BinaryExpr *be = dyn_cast<BinaryExpr>(expr)) 
  {

    ref<Expr> arr[2];
    /* if child is a concat, replace with revalue */
    if(isa<ConcatExpr>(be->left))
      arr[0] = retvalue;
    else
      arr[0] = comp_symbex_replace_for_retvalue(be->left, retvalue);

    if(isa<ConcatExpr>(be->right))
      arr[1] = retvalue;
    else
      arr[1] = comp_symbex_replace_for_retvalue(be->right, retvalue);

    ref<Expr> tmp = be->rebuild(arr);

    return tmp;

  }

  /* If it is something like [Select w32 (Eq 4 (ReadLSB w32 0 arg_printGesture_1)) 9 4] */
  else if (SelectExpr *se = dyn_cast<SelectExpr>(expr)) 
  {
    //llvm::outs() << "Executor::comp_symbex_replace_for_retvalue():  considerting select:\n" << *se << "\n";
    ref<Expr> arr[3];
    if(isa<ConcatExpr>(se->cond))
      arr[0] = retvalue;
    else
      arr[0] = comp_symbex_replace_for_retvalue(se->cond, retvalue);

    if(isa<ConcatExpr>(se->trueExpr))
      arr[1] = retvalue;
    else
      arr[1] = comp_symbex_replace_for_retvalue(se->trueExpr, retvalue);

    if(isa<ConcatExpr>(se->falseExpr))
      arr[2] = retvalue;
    else
      arr[2] = comp_symbex_replace_for_retvalue(se->falseExpr, retvalue);

    ref<Expr> tmp = se->rebuild(arr);

    return tmp;

  }
  assert(0 && "expression type is not supported yet");
}

/* Extract call symbolic replacements from <retvalue>
 *
 * We need this funcntion to understand how many symbolic replacements
 * are a part of the return value. We use it to decide if we need to pass
 * some constraints to a supplimentray function.
 *
 * @param state Execution state from which we check symbolic replacements
 * @param retvalue The return value of the function that the <state> is executing
 * @return vector of symbolic replacements which are a part of retvalue
 */
std::vector<ref<Expr> > extract_call_symbolics_from_expression(ExecutionState *state, ref<Expr> retvalue)
{
  llvm::Function *cur_func = state->prevPC->inst->getParent()->getParent();
  std::vector<ref<Expr> > res;
  for(call_symbolic_replacements_ty::iterator it_1  = state->call_symbolic_replacements[cur_func].begin();
                                              it_1 != state->call_symbolic_replacements[cur_func].end(); ++it_1)
  {
    ref<Expr> symbolics = it_1->first;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(retvalue);
    for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
    { 
      ref<Expr> concat = *it_2;
      if( symbolics == concat) 
      {
        res.push_back(symbolics);
        break;
      }
    }
  }
  return res;
}

std::vector<ref<Expr> > extract_call_symbolics_from_expression(PathSummary *smmry, ref<Expr> retvalue)
{
  std::vector<ref<Expr> > res;
  for(call_symbolic_replacements_ty::iterator it_1  = smmry->call_symbolic_replacements.begin();
                                              it_1 != smmry->call_symbolic_replacements.end(); ++it_1)
  {
    ref<Expr> symbolics = it_1->first;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(retvalue);
    for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
    { 
      ref<Expr> concat = *it_2;
      if( symbolics == concat) 
      {
        res.push_back(symbolics);
        break;
      }
    }
  }
  return res;
}

std::vector<ref<Expr> > Executor::extract_constraints_for_symbolics(ConstraintManager &path_constraints, ref<Expr> &e)
{
  std::vector<ref<Expr> > res;
  for(std::vector< ref<Expr> >::const_iterator it_1  = path_constraints.begin(); 
                                               it_1 != path_constraints.end(); ++it_1) //For each condition in the summary
  {
    const ref<Expr> cond = *it_1;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(cond);
    for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
    { 
      ref<Expr> concat = *it_2;
      if(e == concat) 
      {
        res.push_back(cond);
        break;
      }
    }
  }
  return res;
}


void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
  Instruction *i = ki->inst;
  switch (i->getOpcode()) {
    // Control flow
  case Instruction::Ret: {
    ReturnInst *ri = cast<ReturnInst>(i);
    KInstIterator kcaller = state.stack.back().caller;
    Instruction *caller = kcaller ? kcaller->inst : 0;
    bool isVoidReturn = (ri->getNumOperands() == 0);
    ref<Expr> result = ConstantExpr::alloc(0, Expr::Bool);

    /* We are going one level up =>  remove the last *callInst from call
     * history */
    if(state.callHistory.size() != 0)
      state.callHistory.pop_back();
    /* *** */
    
    
    /* Check if we are returning from an ISR */
		bool interruptExit = false;
		if (state.interruptFun && (ki->inst->getParent()->getParent() == state.interruptFun))
    {
      interruptExit = true;
      state.interruptFun = NULL;
		}
    /* *** */
    
    if (!isVoidReturn) {
      result = eval(ki, 0, state).value;
      //llvm::outs() << "DEBUG: executeInstruction:Ret : result = " <<  result << "\n";
    }
    
    /* It is top-level function: we have just one stack frame */
    if (state.stack.size() <= 1) {
      assert(!caller && "caller set on initial stack frame");

      // IVAN ADDITIONS BEGIN
      if(!forward_symbex && (state.cur_inner_call != NULL)) // If we do backward symbex for suppl call, we need to:
                          // 1) collect the function summary on exit
                          // 2) if the return conditions are satisfied, we save the good_path_summary and terminate the exection for this function
                          // 3) if the return value is not a constant, we need to pass the return value constraints to the next summary
      {
        llvm::outs() << "DEBUG: executeInstruction:Ret : Terminating state on exit, result = " <<  result << "\n";
        llvm::Function *cur_func = ri->getParent()->getParent();

        ConstantExpr *ce = dyn_cast<ConstantExpr>(result);
        /* If return value is a call symbolics, we need to pass
         * current retavlue conditions to the corresponding suppl call*/
        if (!ce) 
        {
          llvm::outs() << "Executor::executeInstruction(): Ret: result is not a constant! " << result << "\n";
          std::vector<ref<Expr> > symbs = extract_call_symbolics_from_expression(&state, result);
          
          llvm::outs() << "Executor::executeInstruction(): Ret: result contains " << symbs.size() << " call symbolics.\n";
          // So our return value is symbolic => return constraints will always be satisfied.
          // We need to pass constraints on this symbolics to the corresponding suppl call.
          assert( (symbs.size() <= 1) && "Complex symbolic return values are not supported yet");
          
          if(symbs.size() == 1)
          {
            llvm::outs() << "Executor::executeInstruction(): Ret: adding the current state's retval_conditions to suppl call:\n";
            print_expressions(*state.ret_value_constraints);
            InnerCall *supp_call = state.call_symbolic_replacements[cur_func][symbs[0]];
            //llvm::outs() << "Executor::executeInstruction(): Ret: retval_conditions before addition: \n";
            //print_expressions(supp_call.retval_conditions);
            supp_call->retval_conditions.insert(supp_call->retval_conditions.end(),
                         state.ret_value_constraints->begin(), state.ret_value_constraints->end());
            //llvm::outs() << "Executor::executeInstruction(): Ret: retval_conditions after addition: \n";
            //print_expressions(supp_call.retval_conditions);
          }
        }

        llvm::outs() << "executeInstruction:Ret : creating new path summary with the following path constraints:\n";
        std::string constraints;
        getConstraintLog(state, constraints, KQUERY);
        llvm::outs() << "                           constraints for the state: \n" << constraints;
        llvm::outs() << "Adding new path summary for function " << cur_func->getName() 
                     << "(); ret value = " << result << "\n";


        path_summary_ty *smmry = new PathSummary(cur_func, result, state.constraints);
        smmry->call_symbolic_replacements = state.call_symbolic_replacements[cur_func];
        smmry->fargs = fargs[cur_func];
        smmry->extract_constraints_on_globals();
        smmry->path_choices = state.path_choices;
        smmry->path_choices_debug = state.path_choices_debug;
        //smmry->path_instructions = state.path_instructions;
        smmry->path_instructions = state.stack.back().path_instructions;
        path_summaries[cur_func].push_back(smmry);
        
        // Now we need to check if the function return value satisifeid composit symbex conditions
        //if(state.ret_value_constraints != NULL) // It is non NULL, only for suppl calls
        if(state.cur_inner_call != NULL) // It is non NULL, only for suppl calls. Seems that this check is redundant
        {
          /* If the result is symbolic, then we might have constraints on it in the path constraints */
          std::vector<ref<Expr> > retvalue_conditions = extract_constraints_for_symbolics(state.constraints, result);
          retvalue_conditions.insert(retvalue_conditions.end(), state.ret_value_constraints->begin(),
                                       state.ret_value_constraints->end());

          llvm::outs() << "Executor::executeInstruction(): Ret: state.ret_value_constraints:\n";
          print_expressions(*state.ret_value_constraints);

          llvm::outs() << "Executor::executeInstruction(): Ret: we reached a return instruction and the ret_value_constraitns are not NULL => " <<
                          "let's check if the following conditions are satisfied (retvalue_conditions.size() = " << 
                            retvalue_conditions.size() << "):\n";
          print_expressions(retvalue_conditions);
          
          llvm::outs() << " ---\n";
          //if(conds_are_solvable(result, state.ret_value_constraints)) // this will replace all concats with result, and check if result satisfies state.ret_value_constraints
          
          
          /* If the return value is one of the formal arguments, then we need
             to add constraints on that formal arg to retvalue_conds */
          llvm::outs() << "Looking at formal args constrain smmry.fargs.size() = " << smmry->fargs.size() << ":\n";
          for(unsigned i = 0; i<smmry->fargs.size(); i++)
          {
            llvm::outs() << "Looking at " << smmry->fargs[i] << "\n";
            if(result == smmry->fargs[i])
            {
              llvm::outs() << "Adding the following constraints to retvalue conds (due to formal args):\n";
              print_expressions(state.cur_inner_call->formal_args_conditions[i]);
              retvalue_conditions.insert(retvalue_conditions.end(), state.cur_inner_call->formal_args_conditions[i].begin(), state.cur_inner_call->formal_args_conditions[i].end());
            }
          }
          
	  /* First checck result expression satisfies conditions from upper
	   * level function summary, and formal args conditions */
          if(conds_are_solvable(result, &retvalue_conditions)) // this will replace all concats with result, and check if result satisfies state.ret_value_constraints
          {
	    /* Second, check if the summary constraints (inherited from the
	     * state) are compatible with format args conditions put by upper
	     * level function */
            if(check_formal_args_against_fsummary(*smmry, state.cur_inner_call->formal_args_conditions))
            {
              //comp_symbex_target_reached = 1;
              state.cur_inner_call->path_summary_found = true;
              llvm::outs() << "DEBUG: the return value is good!\n";
              llvm::outs() << "Adding new path good summary for function " << cur_func->getName()  << " and terminating the state\n";
              good_path_summaries[cur_func].push_back(smmry);
            }
          } else 
            llvm::outs() << "DEBUG: the return value is not good. Continue symbolic execution\n";
        }
        if(path_summaries[cur_func].size() >= min_num_of_summaries_to_collect)
        {
          should_collect_more_summaries[cur_func] = false;
          llvm::outs() << "Executor::executeInstruction(): Ret: we collected the minimum number of path constraints. Stopping the run\n";
          comp_symbex_target_reached = 1;
        }
      }
      /* We just terminate the state if:
         a) If it is forward symbex, or
	       b) It is not a inner_call (in which case we a call to the next
	          function on the path)
      */
      ///IVAN ADDITIONS END
      print_state_constraints(&state);
      terminateStateOnExit(state);
    } else {
      StackFrame &sf = state.stack.back();
	    KInstIterator restorePC = sf.restorePC;
      if (interruptExit) //Restore BBIncomingIndex
				state.incomingBBIndex = state.stack.back().incomingBBIndex;
			
      state.popFrame();

      if (statsTracker)
        statsTracker->framePopped(state);

      if (InvokeInst *ii = dyn_cast<InvokeInst>(caller)) {
        transferToBasicBlock(ii->getNormalDest(), caller->getParent(), state);
      } else {
        /* If we return from an interrupt we need to use <restorePC>,
         * see the description of ExecutionState::pushFrame() for explanation */
        if (restorePC && interruptExit)
          state.pc = restorePC;
        else
        {
          state.pc = kcaller;
          ++state.pc;
        }
      }

      if (!isVoidReturn) {
        LLVM_TYPE_Q Type *t = caller->getType();
        if (t != Type::getVoidTy(getGlobalContext())) {
          // may need to do coercion due to bitcasts
          Expr::Width from = result->getWidth();
          Expr::Width to = getWidthForLLVMType(t);
            
          if (from != to) {
            CallSite cs = (isa<InvokeInst>(caller) ? CallSite(cast<InvokeInst>(caller)) : 
                           CallSite(cast<CallInst>(caller)));

            // XXX need to check other param attrs ?
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
      bool isSExt = cs.paramHasAttr(0, llvm::Attribute::SExt);
#elif LLVM_VERSION_CODE >= LLVM_VERSION(3, 2)
	    bool isSExt = cs.paramHasAttr(0, llvm::Attributes::SExt);
#else
	    bool isSExt = cs.paramHasAttr(0, llvm::Attribute::SExt);
#endif
            if (isSExt) {
              result = SExtExpr::create(result, to);
            } else {
              result = ZExtExpr::create(result, to);
            }
          }

          bindLocal(kcaller, state, result);
        }
      } else {
        // We check that the return value has no users instead of
        // checking the type, since C defaults to returning int for
        // undeclared functions.
        if (!caller->use_empty()) {
          terminateStateOnExecError(state, "return void when caller expected a result");
        }
      }
    }      
    break;
  }
#if LLVM_VERSION_CODE < LLVM_VERSION(3, 1)
  case Instruction::Unwind: {
    for (;;) {
      KInstruction *kcaller = state.stack.back().caller;
      state.popFrame();

      if (statsTracker)
        statsTracker->framePopped(state);

      if (state.stack.empty()) {
        terminateStateOnExecError(state, "unwind from initial stack frame");
        break;
      } else {
        Instruction *caller = kcaller->inst;
        if (InvokeInst *ii = dyn_cast<InvokeInst>(caller)) {
          transferToBasicBlock(ii->getUnwindDest(), caller->getParent(), state);
          break;
        }
      }
    }
    break;
  }
#endif
  case Instruction::Br: {
    BranchInst *bi = cast<BranchInst>(i);
    if (bi->isUnconditional()) {
      transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), state);
    } else {
      // FIXME: Find a way that we don't have this hidden dependency.
      assert(bi->getCondition() == bi->getOperand(0) &&
             "Wrong operand index!");
      ref<Expr> cond = eval(ki, 0, state).value;
      outs() << "Executor::executeInstruction()::Br: cond = " << cond << "\n";
      Executor::StatePair branches = fork(state, cond, false);

      // NOTE: There is a hidden dependency here, markBranchVisited
      // requires that we still be in the context of the branch
      // instruction (it reuses its statistic id). Should be cleaned
      // up with convenient instruction specific data.
      if (statsTracker && state.stack.back().kf->trackCoverage)
        statsTracker->markBranchVisited(branches.first, branches.second);

      if (branches.first)
      {
        outs() << "Executor::executeInstruction()::Br: branches.first is not NULL\n";
        transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
      }
      // IVAN ADDITIONS BEGIN
      else 
      {
        BasicBlock *trueBlock = bi->getSuccessor(0);
        Function *f = bi->getParent()->getParent();
        // If the infeasable true branch is on the path
        //if(state.isOnPath == true)
        if(std::find(cfg_paths[f].begin(),cfg_paths[f].end(),trueBlock) != cfg_paths[f].end())
        {
          state.path_arc_falures[bi->getParent()].first++;
          outs() << "DEBUG: Path goes through True branch, but this branch is infeasable (number of failures = " 
                 << state.path_arc_falures[bi->getParent()].first << ").\n";
          if(state.path_arc_falures[bi->getParent()].first >= 1)
          {
            outs() << "DEBUG: Rebuildig infeasable True arc.\n";
            rebuildInfeasableCFGPath(bi->getParent(), bi->getSuccessor(0));
            print_path2(); // path_function[0] shoud be main; the second arg = 0 defines the identation
            searcher->set_path_functions(path_functions);
            searcher->set_cfg_paths(cfg_paths);
            searcher->set_path(path);
          }
        }
      }
      // IVAN ADDITIONS END

      if (branches.second)
      {
        outs() << "Executor::executeInstruction()::Br: branches.second is not NULL\n";
        transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
      }
      // IVAN ADDITIONS BEGIN
      else 
      {
        BasicBlock *falseBlock = bi->getSuccessor(1);
        Function *f = bi->getParent()->getParent();
        // If false branch is on the path
        //if(state.isOnPath == true)
        if(std::find(cfg_paths[f].begin(),cfg_paths[f].end(),falseBlock) != cfg_paths[f].end())
        {
          state.path_arc_falures[bi->getParent()].second++;
          outs() << "DEBUG: Path goes through False branch, but this branch is infeasable (number of failures = " 
                 << state.path_arc_falures[bi->getParent()].second << ").\n";
          if(state.path_arc_falures[bi->getParent()].second >= 1)
          {
            outs() << "DEBUG: Rebuildig infeasable False arc.\n";
            // Path between on-path blocks looks to be infeasable (bi->geParent() -- bi->getSuccessor(1))
            // We will try to find another path
            rebuildInfeasableCFGPath(bi->getParent(), bi->getSuccessor(1));
            print_path2(); // path_function[0] shoud be main; the second arg = 0 defines the identation
            searcher->set_path_functions(path_functions);
            searcher->set_cfg_paths(cfg_paths);
            searcher->set_path(path);
          }
        }
      }
      // IVAN ADDITIONS END
    }
    break;
  }
  case Instruction::Switch: {
    SwitchInst *si = cast<SwitchInst>(i);
    ref<Expr> cond = eval(ki, 0, state).value;
    BasicBlock *bb = si->getParent();
    //exit(0);

    cond = toUnique(state, cond);
    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(cond)) {
      // Somewhat gross to create these all the time, but fine till we
      // switch to an internal rep.
      LLVM_TYPE_Q llvm::IntegerType *Ty = 
        cast<IntegerType>(si->getCondition()->getType());
      ConstantInt *ci = ConstantInt::get(Ty, CE->getZExtValue());
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 1)
      unsigned index = si->findCaseValue(ci).getSuccessorIndex();
#else
      unsigned index = si->findCaseValue(ci);
#endif
      /// IVAN ADDITIONS START
      state.path_choices.push_back(index+2); // +2 is to differentiate from if-then-else conditions
      /// IVAN ADDITIONS END
      transferToBasicBlock(si->getSuccessor(index), si->getParent(), state);
    } else {
      std::map<BasicBlock*, ref<Expr> > targets;
      ref<Expr> isDefault = ConstantExpr::alloc(1, Expr::Bool);
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 1)      
      for (SwitchInst::CaseIt i = si->case_begin(), e = si->case_end();
           i != e; ++i) {
        ref<Expr> value = evalConstant(i.getCaseValue());
#else
      for (unsigned i=1, cases = si->getNumCases(); i<cases; ++i) {
        ref<Expr> value = evalConstant(si->getCaseValue(i));
#endif
        ref<Expr> match = EqExpr::create(cond, value);
        isDefault = AndExpr::create(isDefault, Expr::createIsZero(match));
        bool result;
        bool success = solver->mayBeTrue(state, match, result);
        assert(success && "FIXME: Unhandled solver failure");
        (void) success;
        if (result) {
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 1)
          BasicBlock *caseSuccessor = i.getCaseSuccessor();
#else
          BasicBlock *caseSuccessor = si->getSuccessor(i);
#endif
          std::map<BasicBlock*, ref<Expr> >::iterator it =
            targets.insert(std::make_pair(caseSuccessor,
                           ConstantExpr::alloc(0, Expr::Bool))).first;

          it->second = OrExpr::create(match, it->second);
        }
      }
      bool res;
      bool success = solver->mayBeTrue(state, isDefault, res);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      if (res)
        targets.insert(std::make_pair(si->getDefaultDest(), isDefault));
      
      std::vector< ref<Expr> > conditions;
      for (std::map<BasicBlock*, ref<Expr> >::iterator it = 
             targets.begin(), ie = targets.end();
           it != ie; ++it)
        conditions.push_back(it->second);
      
      std::vector<ExecutionState*> branches;
      branch(state, conditions, branches);
        
      std::vector<ExecutionState*>::iterator bit = branches.begin();
      /// IVAN ADDITIONS START
      int k = 0;
      /// IVAN ADDITIONS END
      for (std::map<BasicBlock*, ref<Expr> >::iterator it = 
             targets.begin(), ie = targets.end();
           it != ie; ++it) {
        ExecutionState *es = *bit;
        if (es)
        {
          /// IVAN ADDITIONS START
          es->path_choices.push_back(k); /* it's not really an index in switch expression; <k> rather depends on
                                            on the sorting order of <targets> which should be the same across the
                                            same run of klee */
          /// IVAN ADDITIONS END
          transferToBasicBlock(it->first, bb, *es);
        }
        ++bit;
        k++;
      }
    }
    break;
 }
  case Instruction::Unreachable:
    // Note that this is not necessarily an internal bug, llvm will
    // generate unreachable instructions in cases where it knows the
    // program will crash. So it is effectively a SEGV or internal
    // error.
    terminateStateOnExecError(state, "reached \"unreachable\" instruction");
    break;

  case Instruction::Invoke:
  case Instruction::Call: {
    CallSite cs(i);

    unsigned numArgs = cs.arg_size();
    Value *fp = cs.getCalledValue();
    Function *f = getTargetFunction(fp, state);


    // Skip debug intrinsics, we can't evaluate their metadata arguments.
    if (f && isDebugIntrinsic(f, kmodule))
      break;

    if (isa<InlineAsm>(fp)) {
      terminateStateOnExecError(state, "inline assembly is unsupported");
      break;
    }
    // evaluate arguments
    std::vector< ref<Expr> > arguments;
    arguments.reserve(numArgs);

    for (unsigned j=0; j<numArgs; ++j)
      arguments.push_back(eval(ki, j+1, state).value);

    if (f) {

      /// IVAN ADDITIONS BEGIN
      
      /* replacing function call with a symbolic value
       *   <f> is a called function
       *   <ki>, <i> is the current instruction
     
       * In case of backward symbex: If it is not a declaration and is not the target function (i.e. the function that 
       * leads us further in the call graph), we don't call the function, but just make the return
       * result symbolic and break the switch statement .*/
      if (!forward_symbex && !f->isDeclaration() && (f != state.target_func))
      {


        if((f->getName().str() == "klee_div_zero_check") || (f->getName().str() == "memset"))
        {
          //llvm::outs() << "Executor::explore_inner_call(): skipping klee_div_zero_check.\n";
          break;
        }

        //if(f->getName().str() == "abs_")
        //{
        //  llvm::outs() << "Executor::explore_inner_call(): skipping abs_.\n";
        //  break;
        //}

        //if(f->getName().str() == "avg")
        //{
        //  llvm::outs() << "Executor::explore_inner_call(): skipping avg.\n";
        //  break;
        //}


        llvm::outs() << "Executor::executeInstruction():Call: replacing call instruction '" << *(ki->inst) << "' with symbolic variable.\n";
        ref<Expr> result = ConstantExpr::alloc(0, Expr::Bool);
        static unsigned id = 0;

        llvm::Type *return_type = f->getReturnType();
        unsigned w = 0;
        if(isa<llvm::PointerType>(return_type))
        {
          llvm::outs() << "Executor::executeInstruction(): fun return type is a pointer\n";
          w = Context::get().getPointerWidth() / 8;
        }
        else
          w = getIntTypeWidth(return_type);
        assert(w && "Return width cannot be zero");

        //unsigned w = 32;

        const Array *array = Array::CreateArray("res_" + f->getName().str() + "_" + llvm::utostr(id), Expr::getMinBytesForWidth(w) );
        id++;
        result = Expr::createTempRead(array, w);
        llvm::outs() << "Executor::executeInstruction(): creating new symbolic array with size " << w << "\n";
        bindLocal(ki, state, result);
        CallInst *ci = dyn_cast<CallInst>(i);
        llvm::Function *cur_func = i->getParent()->getParent();

        /* Create a new call symbolic replacement and add it to to the list of symbolics
         * for the current state. */
        //state.call_symbolic_replacements[cur_func][result] = InnerCall(result, ci); // result is a symbolic expression
        InnerCall *new_inner_call = new InnerCall(result, ci); // result is a symbolic expression
        unsigned seq_num = state.call_symbolic_replacements[cur_func].size(); // We start seq_num's from 0
        new_inner_call->seq_num = seq_num;
        //state.call_symbolic_replacements[cur_func][result].seq_num = seq_num;

        /* Extract constraints on actual arguments (we will use them as constraints of formal arguments when
         * we execute the supplementary call */
        new_inner_call->update_formal_args_conds(state.constraints, arguments);

        llvm::outs() << "Executor::executeInstruction():Call: updating constrains on globals for Suppl call "
                     << "for " << *ci << "\n";
        llvm::outs() << "Executor::executeInstruction():Call: we have the following path constraints so far:\n";
        print_state_constraints(&state);
        new_inner_call->update_constraints_on_globals(state.global_symbolic_replacements, state.constraints);
        state.call_symbolic_replacements[cur_func][result] = new_inner_call;

        llvm::outs() << "DEBUG:Executor::executeInstruction()::Call: As we have a function call => we should assume that global variables have changed\n";


        // This should assign a new symbolic value to the global value
        std::vector<llvm::Value *> globals = get_global_calling_context(cur_func); // get the list of global variables which are read and written in the function
        for(std::vector<llvm::Value *>::iterator it = globals.begin(); it != globals.end(); ++it)
        {
          MemoryObject* mo = globalObjects[(GlobalValue *)(*it)];
          unsigned id = 0;
          std::string name = (*it)->getName().str();
          std::string uniqueName = name;
          while (!state.arrayNames.insert(uniqueName).second) {
            uniqueName = name + "_" + llvm::utostr(++id);
          }
          const Array *new_array = Array::CreateArray(uniqueName, mo->size);
          bindObjectInState(state, mo, false, new_array);
          state.global_symbolic_replacements[*it].push_back(new_array);
        }

        //std::vector<llvm::Value *> globals = get_global_calling_context(cur_func); // get the list of global variables which are read and written in the function
        //make_globals_symbolic(&state, globals); // This will assign new arrays (with new names) to the globals
        break; 
      }

      if (f && !f->isDeclaration())
        state.callHistory.push_back((Instruction *)i); // add the *CallInst to the end of our call History

      // If we reach the target function (assert()) and we do backward sybmolic execution
      // => let's add a new path summary
      if (!forward_symbex && f && (f == state.target_func) )
      {
        llvm::outs() << "DEBUG: Calling the target function: " << f->getName() << "\n";
        std::string constraints;
        getConstraintLog(state, constraints, KQUERY);
        llvm::outs() << "                           constraints for the state: \n" << constraints;
        llvm::Function *cur_func = i->getParent()->getParent();

        //llvm::outs() << "Executor::executeInstruction()::Call: Checking if the arguments satisfy any of the target function's summary\n";

        
        //llvm::outs() << "DEBUG: Adding new good path summary for function " << cur_func->getName()  << " and terminating the state\n";
        //path_summaries[cur_func].push_back(std::make_pair(ConstantExpr::alloc(0, Expr::Int32), state.constraints));
        //path_summaries[cur_func].push_back(std::make_tuple(ConstantExpr::alloc(0, Expr::Int32),
        //                                   state.constraints, state.target_func, arguments));
        path_summary_ty *new_smmry = new PathSummary(cur_func,
                      ConstantExpr::alloc(0, Expr::Int32), state.constraints, state.target_func, arguments);
        new_smmry->call_symbolic_replacements = state.call_symbolic_replacements[cur_func];
        new_smmry->fargs = fargs[cur_func];
        new_smmry->extract_constraints_on_globals();
        new_smmry->path_choices = state.path_choices;
        new_smmry->path_choices_debug = state.path_choices_debug;
        //new_smmry->path_instructions = state.path_instructions;
        new_smmry->path_instructions = state.stack.back().path_instructions;
        llvm::outs() << "Executor::executeInstruction()::Call: number of call symbolics in path summary = " << 
                        new_smmry->call_symbolic_replacements.size() << "\n";
        llvm::outs() << "Executor::executeInstruction()::Call: number of call symbolics in state = " << 
                        state.call_symbolic_replacements[cur_func].size() << "\n";
        llvm::outs() << "Executor::executeInstruction()::Call: new_smmry.target_func_actual_args.size() = " << 
                        new_smmry->target_func_actual_args.size() << "\n";
        llvm::outs() << "Executor::executeInstruction()::Call: arguments.size() = " << 
                        arguments.size() << "\n";
        llvm::outs() << "Executor::executeInstruction()::Call: numArgs= " << 
                        numArgs << "\n";
        path_summaries[cur_func].push_back(new_smmry);

        terminateStateOnExit(state);

        if(state.target_func != call_path[call_path.size()-1]) // If this is not the target function (i.e. assert())
        {
          llvm::outs() << "Executor::executeInstruction()::Call: state.target_func  = " << state.target_func->getName() << "\n";  
          if(comp_symbex_can_glue(cur_func, state, arguments)) // This will check if we can glue summaries of the current and the next functions; We can finish if we can really glue with some summary
          {
            llvm::outs() << "Executor::executeInstruction()::Call: the current state can be glued with"  
                            " one of the next on-path summaries\n";
            good_path_summaries[cur_func].push_back(new_smmry);
          }
        } else 
        {
          good_path_summaries[cur_func].push_back(new_smmry);
        }

        //if((path_summaries[cur_func].size() >= 5) && (good_path_summaries[cur_func].size() >= 1))
        //if((path_summaries[cur_func].size() >= 1) && (good_path_summaries[cur_func].size() >= 1))
        //if(time(NULL) - build_fsummary_start_timer = 
        //{
        //  llvm::outs() << "Executor::executeInstruction(): Call: we collected the minimum number of call path summaries for " << cur_func->getName() << ". Stopping the run\n";
        //  llvm::outs() << "Executor::executeInstruction(): Call: number of good path summaries = " << good_path_summaries[cur_func].size() << "\n";
        //  for(unsigned i = 0; i<good_path_summaries[cur_func].size(); i++)
        //    print_function_summary(good_path_summaries[cur_func][i]);
        //  comp_symbex_target_reached = 1;
        //}

        break; // We are done with the call instruction
      }
      /// IVAN ADDITIONS END
      
      
      /// IVAN ADDITIONS BEGIN

      /* When we were doing backward symbolic execution, and building the current path summary,
       * we replaceed call instruction with new symbolics and saved them in the
       * <call_symbolic_replacements>. Then for each symbolics we later generated a good path
       * summar which satisfies conditiond on ret value.
       * Now we are  do forward symbolic execution, and for each call, we need to use the right
       * path summary of the called function */
      if(forward_symbex)
      {
        if(f->getName().str() == this->target_function_name) 
        {
          llvm::outs() << "BINGO! Here is are the constraints in KQUERY format:\n";
          print_state_constraints(&state);

          llvm::outs() << "And here is are the constraints in SMTLIB2 format:\n";
          std::string constraints;
          getConstraintLog(state, constraints, SMTLIB2);
          llvm::outs() << constraints << "\n";

          exit(0);
          comp_symbex_target_reached = 1;
          return;
        }

        llvm::outs() << "Executor::executeInstruction():: Call: we are in forward_symbex and are going"
                        " to find a good path summary for " << f->getName() << "()\n";
        llvm::Function *cur_func = i->getParent()->getParent();
        //path_summary_ty *next_fsummary;
        //if(is_part_of_callpath(f))
        /* Updating state->cur_fsummary. We'll use this value in
         * executeCall to update stack frame cur_fsummary. */ 
        if(state.cur_fsummary && (f == state.cur_fsummary->target_func)) // If we call the next function in call graph; target_func is NULL for inner_calls
        {
          //state.cur_callgraph_fsummary = state.next_callgraph_fsummary;
          //next_fsummary = find_next_callgraph_psummary(state.cur_callgraph_fsummary,cur_func);
          //next_fsummary = find_next_callgraph_psummary(state.cur_callgraph_fsummary,f);
          //state.next_callgraph_fsummary = state.cur_callgraph_fsummary->next_fsummary;
          //state.cur_callgraph_fsummary->update_InnerCalls_with_constraints2(*next_fsummary);
          state.cur_fsummary = state.cur_fsummary->next_path_summary;
          llvm::outs() << "Executor::executeInstruction():: Call: using the following summary"
                          " for on-call-path function " << f->getName() << "\n";
          print_function_summary(state.cur_fsummary);
        }
        else if(state.cur_fsummary && !f->isDeclaration() && (f->getName().str() != "klee_div_zero_check")
                                  && (f->getName().str() != "memset"))/* else it is a suppl call */
        {
          StackFrame &sf = state.stack.back();
          llvm::outs() << "Executor::executeInstruction():: Call: searching suppl call for function " << cur_func->getName()
                       << " and seq_num = " << sf.cur_call_symbolics_seq_num << "\n";
          InnerCall *inner_call = get_InnerCall_by_seqnum(state.cur_fsummary, sf.cur_call_symbolics_seq_num);
          assert(inner_call && "could not find suppl call by seq_num");
          sf.cur_call_symbolics_seq_num++;

          /* If there are connected summaries, we run
           * executeCall for each of them and the break the switch
           * statement */
          unsigned N = inner_call->connected_summaries.size();
          if(N != 0)
          {
            //state.cur_fsummary = inner_call->connected_summaries[0];
            std::vector<ExecutionState*> branches;
            branch_connected_summaries(state, N, branches);
            for(unsigned k = 0; k < N; k++)
            {
              ExecutionState *es = branches[k];
              assert(es && "Execution state after branch_connected_summaries is NULL");
              es->cur_fsummary = inner_call->connected_summaries[k];
              //llvm::outs() << "Executor::executeInstruction():: Call: using the following summary"
              //                " for inner_call function " << cur_func->getName() << "\n";
              //print_function_summary(state.cur_fsummary);
              executeCall(*es, ki, f, arguments);
            }
            break; /* Break switch statemen here */
          }
          /* Else set the cur_summary to NULL and proceed with usual flow */
          else
          {
            state.cur_fsummary = NULL;
            //llvm::outs() << "Executor::executeInstruction():: Call: using the following summary"
            //                " for inner_call function " << cur_func->getName() << "\n";
            //print_function_summary(state.cur_fsummary);
          }
        } else /* It's a suppl call for which we dicided not to search for summaries */
        {
          assert(!is_part_of_callpath(f) && "state.cur_fsummary is NULL and we are going to call on-call-path function");
          state.cur_fsummary = NULL;
          llvm::outs() << "Executor::executeInstruction():: Call: cur path summary is NULL or f is decl only ("
                       << (f->isDeclaration() ? "true" : "false") << ") or it's klee_div_zero_check() (" <<
                          ((f->getName().str() == "klee_div_zero_check") ? "true" : "false") << ") leaving cur summary as NULL\n";
        }

      }


      /// IVAN ADDITIONS END


      
      
      const FunctionType *fType = 
        dyn_cast<FunctionType>(cast<PointerType>(f->getType())->getElementType());
      const FunctionType *fpType =
        dyn_cast<FunctionType>(cast<PointerType>(fp->getType())->getElementType());

      // special case the call with a bitcast case
      if (fType != fpType) {
        assert(fType && fpType && "unable to get function type");

        // XXX check result coercion

        // XXX this really needs thought and validation
        unsigned i=0;
        for (std::vector< ref<Expr> >::iterator
               ai = arguments.begin(), ie = arguments.end();
             ai != ie; ++ai) {
          Expr::Width to, from = (*ai)->getWidth();
            
          if (i<fType->getNumParams()) {
            to = getWidthForLLVMType(fType->getParamType(i));

            if (from != to) {
              // XXX need to check other param attrs ?
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
              bool isSExt = cs.paramHasAttr(i+1, llvm::Attribute::SExt);
#elif LLVM_VERSION_CODE >= LLVM_VERSION(3, 2)
	      bool isSExt = cs.paramHasAttr(i+1, llvm::Attributes::SExt);
#else
	      bool isSExt = cs.paramHasAttr(i+1, llvm::Attribute::SExt);
#endif
              if (isSExt) {
                arguments[i] = SExtExpr::create(arguments[i], to);
              } else {
                arguments[i] = ZExtExpr::create(arguments[i], to);
              }
            }
          }
            
          i++;
        }
      }

      executeCall(state, ki, f, arguments);
    } else {
      ref<Expr> v = eval(ki, 0, state).value;

      ExecutionState *free = &state;
      bool hasInvalid = false, first = true;

      /* XXX This is wasteful, no need to do a full evaluate since we
         have already got a value. But in the end the caches should
         handle it for us, albeit with some overhead. */
      do {
        ref<ConstantExpr> value;
        bool success = solver->getValue(*free, v, value);
        assert(success && "FIXME: Unhandled solver failure");
        (void) success;
        StatePair res = fork(*free, EqExpr::create(v, value), true);
        if (res.first) {
          uint64_t addr = value->getZExtValue();
          if (legalFunctions.count(addr)) {
            f = (Function*) addr;

            // Don't give warning on unique resolution
            if (res.second || !first)
              klee_warning_once((void*) (unsigned long) addr, 
                                "resolved symbolic function pointer to: %s",
                                f->getName().data());

            executeCall(*res.first, ki, f, arguments);
          } else {
            if (!hasInvalid) {
              terminateStateOnExecError(state, "invalid function pointer");
              hasInvalid = true;
            }
          }
        }

        first = false;
        free = res.second;
      } while (free);
    }
    break;
  }
  case Instruction::PHI: {
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 0)
    ref<Expr> result = eval(ki, state.incomingBBIndex, state).value;
#else
    ref<Expr> result = eval(ki, state.incomingBBIndex * 2, state).value;
#endif
    bindLocal(ki, state, result);
    break;
  }

    // Special instructions
  case Instruction::Select: {
    ref<Expr> cond = eval(ki, 0, state).value;
    ref<Expr> tExpr = eval(ki, 1, state).value;
    ref<Expr> fExpr = eval(ki, 2, state).value;
    ref<Expr> result = SelectExpr::create(cond, tExpr, fExpr);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::VAArg:
    terminateStateOnExecError(state, "unexpected VAArg instruction");
    break;

    // Arithmetic / logical

  case Instruction::Add: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    bindLocal(ki, state, AddExpr::create(left, right));
    break;
  }

  case Instruction::Sub: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    bindLocal(ki, state, SubExpr::create(left, right));
    break;
  }
 
  case Instruction::Mul: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    bindLocal(ki, state, MulExpr::create(left, right));
    break;
  }

  case Instruction::UDiv: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = UDivExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::SDiv: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = SDivExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::URem: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = URemExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }
 
  case Instruction::SRem: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = SRemExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::And: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = AndExpr::create(left, right);
    llvm::outs() << "Executor::executeInstruction(): And: " << result << "\n";
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::Or: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = OrExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::Xor: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = XorExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::Shl: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = ShlExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::LShr: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = LShrExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::AShr: {
    ref<Expr> left = eval(ki, 0, state).value;
    ref<Expr> right = eval(ki, 1, state).value;
    ref<Expr> result = AShrExpr::create(left, right);
    bindLocal(ki, state, result);
    break;
  }

    // Compare

  case Instruction::ICmp: {
    CmpInst *ci = cast<CmpInst>(i);
    ICmpInst *ii = cast<ICmpInst>(ci);
 
    switch(ii->getPredicate()) {
    case ICmpInst::ICMP_EQ: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = EqExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_NE: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = NeExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_UGT: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = UgtExpr::create(left, right);
      bindLocal(ki, state,result);
      break;
    }

    case ICmpInst::ICMP_UGE: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = UgeExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_ULT: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = UltExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_ULE: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = UleExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_SGT: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = SgtExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_SGE: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = SgeExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_SLT: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = SltExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    case ICmpInst::ICMP_SLE: {
      ref<Expr> left = eval(ki, 0, state).value;
      ref<Expr> right = eval(ki, 1, state).value;
      ref<Expr> result = SleExpr::create(left, right);
      bindLocal(ki, state, result);
      break;
    }

    default:
      terminateStateOnExecError(state, "invalid ICmp predicate");
    }
    break;
  }
 
    // Memory instructions...
  case Instruction::Alloca: {
    AllocaInst *ai = cast<AllocaInst>(i);
    unsigned elementSize = 
      kmodule->targetData->getTypeStoreSize(ai->getAllocatedType());
    ref<Expr> size = Expr::createPointer(elementSize);
    if (ai->isArrayAllocation()) {
      ref<Expr> count = eval(ki, 0, state).value;
      count = Expr::createZExtToPointerWidth(count);
      size = MulExpr::create(size, count);
    }
    bool isLocal = i->getOpcode()==Instruction::Alloca;
    executeAlloc(state, size, isLocal, ki);
    break;
  }

  case Instruction::Load: {
    ref<Expr> base = eval(ki, 0, state).value;
    //llvm::outs() << "We have a load instruction with the fowollwing base expression: " << base << "\n";
    llvm::outs() << "Executor::executeInstruction(): Load: base = " << base << "\n";
    executeMemoryOperation(state, false, base, 0, ki);
    break;
  }
  case Instruction::Store: {
    llvm::outs() << "Executing Store instruction\n";
    ref<Expr> base = eval(ki, 1, state).value;
    ref<Expr> value = eval(ki, 0, state).value;
    //llvm::outs() << "MAKAKA\n";
    //llvm::outs() << "Going inside executeMemoryOperation(), value.get() = " << value.get() << "\n";
    //llvm::outs() << "Going inside executeMemoryOperation(), base = " << base << "; value = " << value << "\n";
    //llvm::outs() << "Going inside executeMemoryOperation(), base = " << base << "\n";
    //llvm::outs() << "AKAFDEFF\n";
    llvm::outs() << "Executor::executeInstruction(): Store: base = " << base << "\n";
    executeMemoryOperation(state, true, base, value, 0);
    llvm::outs() << "Returned from executeMemoryOperation()\n";
    break;
  }

  case Instruction::GetElementPtr: {
    KGEPInstruction *kgepi = static_cast<KGEPInstruction*>(ki);
    ref<Expr> base = eval(ki, 0, state).value;
    llvm::outs() << "Executor::executeInstruction(): GetElemetPtr: base = " << base << "\n";

    for (std::vector< std::pair<unsigned, uint64_t> >::iterator 
           it = kgepi->indices.begin(), ie = kgepi->indices.end(); 
         it != ie; ++it) {
      uint64_t elementSize = it->second;
      ref<Expr> index = eval(ki, it->first, state).value;
      llvm::outs() << "Executor::executeInstruction(): GetElemetPtr: considering index " 
                   << index << " with size " << elementSize << "\n";
      base = AddExpr::create(base,
                             MulExpr::create(Expr::createSExtToPointerWidth(index),
                                             Expr::createPointer(elementSize)));
      llvm::outs() << "Executor::executeInstruction(): GetElemetPtr: new base = " << base << "\n";
    }
    if (kgepi->offset)
    {
      base = AddExpr::create(base,
                             Expr::createPointer(kgepi->offset));
      llvm::outs() << "Executor::executeInstruction(): GetElemetPtr:  base after adding offset = " << base << "\n";
    }
    llvm::outs() << "Executor::executeInstruction(): GetElemetPtr:  base to go to bind local = " << base << "\n";
    bindLocal(ki, state, base);
    break;
  }

    // Conversion
  case Instruction::Trunc: {
    CastInst *ci = cast<CastInst>(i);
    ref<Expr> result = ExtractExpr::create(eval(ki, 0, state).value,
                                           0,
                                           getWidthForLLVMType(ci->getType()));
    bindLocal(ki, state, result);
    break;
  }
  case Instruction::ZExt: {
    CastInst *ci = cast<CastInst>(i);
    ref<Expr> result = ZExtExpr::create(eval(ki, 0, state).value,
                                        getWidthForLLVMType(ci->getType()));
    llvm::outs() << "Executor::executeInstruction(): ZExt: " << result << "\n";
    bindLocal(ki, state, result);
    break;
  }
  case Instruction::SExt: {
    CastInst *ci = cast<CastInst>(i);
    ref<Expr> result = SExtExpr::create(eval(ki, 0, state).value,
                                        getWidthForLLVMType(ci->getType()));
    bindLocal(ki, state, result);
    break;
  }

  case Instruction::IntToPtr: {
    CastInst *ci = cast<CastInst>(i);
    Expr::Width pType = getWidthForLLVMType(ci->getType());
    ref<Expr> arg = eval(ki, 0, state).value;
    bindLocal(ki, state, ZExtExpr::create(arg, pType));
    break;
  } 
  case Instruction::PtrToInt: {
    CastInst *ci = cast<CastInst>(i);
    Expr::Width iType = getWidthForLLVMType(ci->getType());
    ref<Expr> arg = eval(ki, 0, state).value;
    bindLocal(ki, state, ZExtExpr::create(arg, iType));
    break;
  }

  case Instruction::BitCast: {
    ref<Expr> result = eval(ki, 0, state).value;
    bindLocal(ki, state, result);
    break;
  }

    // Floating point instructions

  case Instruction::FAdd: {
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FAdd operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(left->getWidth()), left->getAPValue());
    Res.add(APFloat(*fpWidthToSemantics(right->getWidth()),right->getAPValue()), APFloat::rmNearestTiesToEven);
#else
    llvm::APFloat Res(left->getAPValue());
    Res.add(APFloat(right->getAPValue()), APFloat::rmNearestTiesToEven);
#endif
    bindLocal(ki, state, ConstantExpr::alloc(Res.bitcastToAPInt()));
    break;
  }

  case Instruction::FSub: {
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FSub operation");
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(left->getWidth()), left->getAPValue());
    Res.subtract(APFloat(*fpWidthToSemantics(right->getWidth()), right->getAPValue()), APFloat::rmNearestTiesToEven);
#else
    llvm::APFloat Res(left->getAPValue());
    Res.subtract(APFloat(right->getAPValue()), APFloat::rmNearestTiesToEven);
#endif
    bindLocal(ki, state, ConstantExpr::alloc(Res.bitcastToAPInt()));
    break;
  }
 
  case Instruction::FMul: {
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FMul operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(left->getWidth()), left->getAPValue());
    Res.multiply(APFloat(*fpWidthToSemantics(right->getWidth()), right->getAPValue()), APFloat::rmNearestTiesToEven);
#else
    llvm::APFloat Res(left->getAPValue());
    Res.multiply(APFloat(right->getAPValue()), APFloat::rmNearestTiesToEven);
#endif
    bindLocal(ki, state, ConstantExpr::alloc(Res.bitcastToAPInt()));
    break;
  }

  case Instruction::FDiv: {
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FDiv operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(left->getWidth()), left->getAPValue());
    Res.divide(APFloat(*fpWidthToSemantics(right->getWidth()), right->getAPValue()), APFloat::rmNearestTiesToEven);
#else
    llvm::APFloat Res(left->getAPValue());
    Res.divide(APFloat(right->getAPValue()), APFloat::rmNearestTiesToEven);
#endif
    bindLocal(ki, state, ConstantExpr::alloc(Res.bitcastToAPInt()));
    break;
  }

  case Instruction::FRem: {
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FRem operation");
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(left->getWidth()), left->getAPValue());
    Res.mod(APFloat(*fpWidthToSemantics(right->getWidth()),right->getAPValue()),
            APFloat::rmNearestTiesToEven);
#else
    llvm::APFloat Res(left->getAPValue());
    Res.mod(APFloat(right->getAPValue()), APFloat::rmNearestTiesToEven);
#endif
    bindLocal(ki, state, ConstantExpr::alloc(Res.bitcastToAPInt()));
    break;
  }

  case Instruction::FPTrunc: {
    FPTruncInst *fi = cast<FPTruncInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                       "floating point");
    if (!fpWidthToSemantics(arg->getWidth()) || resultType > arg->getWidth())
      return terminateStateOnExecError(state, "Unsupported FPTrunc operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(arg->getWidth()), arg->getAPValue());
#else
    llvm::APFloat Res(arg->getAPValue());
#endif
    bool losesInfo = false;
    Res.convert(*fpWidthToSemantics(resultType),
                llvm::APFloat::rmNearestTiesToEven,
                &losesInfo);
    bindLocal(ki, state, ConstantExpr::alloc(Res));
    break;
  }

  case Instruction::FPExt: {
    FPExtInst *fi = cast<FPExtInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    if (!fpWidthToSemantics(arg->getWidth()) || arg->getWidth() > resultType)
      return terminateStateOnExecError(state, "Unsupported FPExt operation");
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Res(*fpWidthToSemantics(arg->getWidth()), arg->getAPValue());
#else
    llvm::APFloat Res(arg->getAPValue());
#endif
    bool losesInfo = false;
    Res.convert(*fpWidthToSemantics(resultType),
                llvm::APFloat::rmNearestTiesToEven,
                &losesInfo);
    bindLocal(ki, state, ConstantExpr::alloc(Res));
    break;
  }

  case Instruction::FPToUI: {
    FPToUIInst *fi = cast<FPToUIInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                       "floating point");
    if (!fpWidthToSemantics(arg->getWidth()) || resultType > 64)
      return terminateStateOnExecError(state, "Unsupported FPToUI operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Arg(*fpWidthToSemantics(arg->getWidth()), arg->getAPValue());
#else
    llvm::APFloat Arg(arg->getAPValue());
#endif
    uint64_t value = 0;
    bool isExact = true;
    Arg.convertToInteger(&value, resultType, false,
                         llvm::APFloat::rmTowardZero, &isExact);
    bindLocal(ki, state, ConstantExpr::alloc(value, resultType));
    break;
  }

  case Instruction::FPToSI: {
    FPToSIInst *fi = cast<FPToSIInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                       "floating point");
    if (!fpWidthToSemantics(arg->getWidth()) || resultType > 64)
      return terminateStateOnExecError(state, "Unsupported FPToSI operation");
#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    llvm::APFloat Arg(*fpWidthToSemantics(arg->getWidth()), arg->getAPValue());
#else
    llvm::APFloat Arg(arg->getAPValue());

#endif
    uint64_t value = 0;
    bool isExact = true;
    Arg.convertToInteger(&value, resultType, true,
                         llvm::APFloat::rmTowardZero, &isExact);
    bindLocal(ki, state, ConstantExpr::alloc(value, resultType));
    break;
  }

  case Instruction::UIToFP: {
    UIToFPInst *fi = cast<UIToFPInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                       "floating point");
    const llvm::fltSemantics *semantics = fpWidthToSemantics(resultType);
    if (!semantics)
      return terminateStateOnExecError(state, "Unsupported UIToFP operation");
    llvm::APFloat f(*semantics, 0);
    f.convertFromAPInt(arg->getAPValue(), false,
                       llvm::APFloat::rmNearestTiesToEven);

    bindLocal(ki, state, ConstantExpr::alloc(f));
    break;
  }

  case Instruction::SIToFP: {
    SIToFPInst *fi = cast<SIToFPInst>(i);
    Expr::Width resultType = getWidthForLLVMType(fi->getType());
    ref<ConstantExpr> arg = toConstant(state, eval(ki, 0, state).value,
                                       "floating point");
    const llvm::fltSemantics *semantics = fpWidthToSemantics(resultType);
    if (!semantics)
      return terminateStateOnExecError(state, "Unsupported SIToFP operation");
    llvm::APFloat f(*semantics, 0);
    f.convertFromAPInt(arg->getAPValue(), true,
                       llvm::APFloat::rmNearestTiesToEven);

    bindLocal(ki, state, ConstantExpr::alloc(f));
    break;
  }

  case Instruction::FCmp: {
    FCmpInst *fi = cast<FCmpInst>(i);
    ref<ConstantExpr> left = toConstant(state, eval(ki, 0, state).value,
                                        "floating point");
    ref<ConstantExpr> right = toConstant(state, eval(ki, 1, state).value,
                                         "floating point");
    if (!fpWidthToSemantics(left->getWidth()) ||
        !fpWidthToSemantics(right->getWidth()))
      return terminateStateOnExecError(state, "Unsupported FCmp operation");

#if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
    APFloat LHS(*fpWidthToSemantics(left->getWidth()),left->getAPValue());
    APFloat RHS(*fpWidthToSemantics(right->getWidth()),right->getAPValue());
#else
    APFloat LHS(left->getAPValue());
    APFloat RHS(right->getAPValue());
#endif
    APFloat::cmpResult CmpRes = LHS.compare(RHS);

    bool Result = false;
    switch( fi->getPredicate() ) {
      // Predicates which only care about whether or not the operands are NaNs.
    case FCmpInst::FCMP_ORD:
      Result = CmpRes != APFloat::cmpUnordered;
      break;

    case FCmpInst::FCMP_UNO:
      Result = CmpRes == APFloat::cmpUnordered;
      break;

      // Ordered comparisons return false if either operand is NaN.  Unordered
      // comparisons return true if either operand is NaN.
    case FCmpInst::FCMP_UEQ:
      if (CmpRes == APFloat::cmpUnordered) {
        Result = true;
        break;
      }
    case FCmpInst::FCMP_OEQ:
      Result = CmpRes == APFloat::cmpEqual;
      break;

    case FCmpInst::FCMP_UGT:
      if (CmpRes == APFloat::cmpUnordered) {
        Result = true;
        break;
      }
    case FCmpInst::FCMP_OGT:
      Result = CmpRes == APFloat::cmpGreaterThan;
      break;

    case FCmpInst::FCMP_UGE:
      if (CmpRes == APFloat::cmpUnordered) {
        Result = true;
        break;
      }
    case FCmpInst::FCMP_OGE:
      Result = CmpRes == APFloat::cmpGreaterThan || CmpRes == APFloat::cmpEqual;
      break;

    case FCmpInst::FCMP_ULT:
      if (CmpRes == APFloat::cmpUnordered) {
        Result = true;
        break;
      }
    case FCmpInst::FCMP_OLT:
      Result = CmpRes == APFloat::cmpLessThan;
      break;

    case FCmpInst::FCMP_ULE:
      if (CmpRes == APFloat::cmpUnordered) {
        Result = true;
        break;
      }
    case FCmpInst::FCMP_OLE:
      Result = CmpRes == APFloat::cmpLessThan || CmpRes == APFloat::cmpEqual;
      break;

    case FCmpInst::FCMP_UNE:
      Result = CmpRes == APFloat::cmpUnordered || CmpRes != APFloat::cmpEqual;
      break;
    case FCmpInst::FCMP_ONE:
      Result = CmpRes != APFloat::cmpUnordered && CmpRes != APFloat::cmpEqual;
      break;

    default:
      assert(0 && "Invalid FCMP predicate!");
    case FCmpInst::FCMP_FALSE:
      Result = false;
      break;
    case FCmpInst::FCMP_TRUE:
      Result = true;
      break;
    }

    bindLocal(ki, state, ConstantExpr::alloc(Result, Expr::Bool));
    break;
  }
  case Instruction::InsertValue: {
    KGEPInstruction *kgepi = static_cast<KGEPInstruction*>(ki);

    ref<Expr> agg = eval(ki, 0, state).value;
    ref<Expr> val = eval(ki, 1, state).value;

    ref<Expr> l = NULL, r = NULL;
    unsigned lOffset = kgepi->offset*8, rOffset = kgepi->offset*8 + val->getWidth();

    if (lOffset > 0)
      l = ExtractExpr::create(agg, 0, lOffset);
    if (rOffset < agg->getWidth())
      r = ExtractExpr::create(agg, rOffset, agg->getWidth() - rOffset);

    ref<Expr> result;
    if (!l.isNull() && !r.isNull())
      result = ConcatExpr::create(r, ConcatExpr::create(val, l));
    else if (!l.isNull())
      result = ConcatExpr::create(val, l);
    else if (!r.isNull())
      result = ConcatExpr::create(r, val);
    else
      result = val;

    bindLocal(ki, state, result);
    break;
  }
  case Instruction::ExtractValue: {
    KGEPInstruction *kgepi = static_cast<KGEPInstruction*>(ki);

    ref<Expr> agg = eval(ki, 0, state).value;

    ref<Expr> result = ExtractExpr::create(agg, kgepi->offset*8, getWidthForLLVMType(i->getType()));

    bindLocal(ki, state, result);
    break;
  }
 
    // Other instructions...
    // Unhandled
  case Instruction::ExtractElement:
  case Instruction::InsertElement:
  case Instruction::ShuffleVector:
    terminateStateOnError(state, "XXX vector instructions unhandled",
                          "xxx.err");
    break;
 
  default:
    terminateStateOnExecError(state, "illegal instruction");
    break;
  }
}

/// IVAN ADDITIONS START


bool Executor::states_are_equivalent(ExecutionState *s1, ExecutionState *s2)
{

  /* 1. Should point have the same program counter */
  if(s1->pc->inst != s2->pc->inst)
    return false;

  /* 2. Should have the same set of constraints */
  //llvm::outs() << "Executor::states_are_equivalent(): states are at the same instruction. Checking constraints\n";


    //#define IVAN
    #ifdef IVAN
    std::string constraints1;
    getConstraintLog(*s1, constraints1, KQUERY);
    //llvm::errs() << "                           constraints for the state: \n" << constraints;
    llvm::outs() << "                           constraints for the state: \n" << constraints1;
    #endif
    #undef IVAN

    //#define IVAN
    #ifdef IVAN
    std::string constraints2;
    getConstraintLog(*s2, constraints2, KQUERY);
    //llvm::errs() << "                           constraints for the state: \n" << constraints;
    llvm::outs() << "                           constraints for the state: \n" << constraints2;
    #endif
    #undef IVAN

  if(!(s1->constraints == s2->constraints))
    return false;

  /* 3. Should have the same values for used variables (both local and global) */
   /* 3.1 check if the global value have the same values */
   //llvm::outs() << "Executor::states_are_equivalent(): states have the same constraints. Checking memory\n";
   //exit(0);
   llvm::Function *cur_func = s1->pc->inst->getParent()->getParent();
   std::vector<llvm::Value *> globals = get_global_calling_context(cur_func); // get the list of global variables which are read and written in the function
   for(std::vector<llvm::Value *>::iterator it = globals.begin(); it != globals.end(); ++it)
   {
     const MemoryObject* mo = globalObjects[(GlobalValue *)(*it)];
     const ObjectState *os1 = s1->addressSpace.findObject(mo);
     const ObjectState *os2 = s1->addressSpace.findObject(mo);
     if(os1 != os2)
       return false;
     //state.addressSpace.bindObject(mo, os);
     //bindObjectInState(state, mo, false, new_array);
   }
   /* 3.2 Check if the stack frames contain the same values */
   StackFrame &sf1 = s1->stack.back();
   StackFrame &sf2 = s2->stack.back();
   unsigned numRegs = sf1.kf->numRegisters;
   for (unsigned i = 0 ; i < numRegs ; ++i)
     if(!(sf1.locals[i].value == sf2.locals[i].value))
       return false;

  return true;

}

bool Executor::state_can_be_merged(ExecutionState *es) 
{
  for (std::set<ExecutionState*>::iterator it = states.begin(), ie = states.end(); it != ie; ++it)
  {
    ExecutionState *es2 = *it;
    if((es != es2) && states_are_equivalent(es, es2))
      return true;
  }
  return false;
}

/* We don't use this function now */
//void Executor::removeDublicateStates() 
//{
//  std::set<ExecutionState*> states_to_remove;
//  std::set<ExecutionState*> unique;
//
//  /* Exract dublicate states and put them to <states_to_remove> */
//  for (std::set<ExecutionState*>::iterator it_1 = states.begin(), ie_1 = states.end(); it_1 != ie_1; ++it_1)
//  {
//    ExecutionState *es_1 = *it_1;
//    bool should_add = true;
//    for (std::set<ExecutionState*>::iterator it_2 = unique.begin(), ie_2 = unique.end();
//       it_2 != ie_2; ++it_2) {
//      ExecutionState *es_2 = *it_2;
//      if(states_are_equivalent(es_1, es_2))
//      {
//        should_add = false;
//        states_to_remove.insert(es_1);
//        break;
//      }
//    }
//    if(should_add)
//      unique.insert(es_1);
//  }
//
//  /* Remove dublicate states */
//  for (std::set<ExecutionState*>::iterator
//         it = states_to_remove.begin(), ie = states_to_remove.end();
//       it != ie; ++it) {
//
//        terminateStateEarly(state, "does not comply with fsummary.");
//        updateStates(&state);
//        continue;
//    ExecutionState *es = *it;
//    std::set<ExecutionState*>::iterator it2 = states.find(es);
//    assert(it2!=states.end());
//    states.erase(it2);
//    std::map<ExecutionState*, std::vector<SeedInfo> >::iterator it3 = 
//      seedMap.find(es);
//    if (it3 != seedMap.end())
//      seedMap.erase(it3);
//    processTree->remove(es->ptreeNode);
//    delete es;
//  }
//}
///// IVAN ADDITIONS END

void Executor::updateStates(ExecutionState *current) {
  if (searcher) {
    searcher->update(current, addedStates, removedStates);
  }
  
  states.insert(addedStates.begin(), addedStates.end());
  addedStates.clear();
  
  for (std::set<ExecutionState*>::iterator
         it = removedStates.begin(), ie = removedStates.end();
       it != ie; ++it) {
    ExecutionState *es = *it;
    std::set<ExecutionState*>::iterator it2 = states.find(es);
    assert(it2!=states.end());
    states.erase(it2);
    std::map<ExecutionState*, std::vector<SeedInfo> >::iterator it3 = 
      seedMap.find(es);
    if (it3 != seedMap.end())
      seedMap.erase(it3);
    processTree->remove(es->ptreeNode);
    delete es;
  }
  removedStates.clear();
}

/// IVAN ADDITIONS BEGIN
template <typename TypeIt>
void Executor::clearOffsets(KGEPInstruction *kgepi, TypeIt ib, TypeIt ie) {
  uint64_t index = 1;
  for (TypeIt ii = ib; ii != ie; ++ii) {
    if (LLVM_TYPE_Q StructType *st = dyn_cast<StructType>(*ii)) {
         // PASS
    } else {
      Value *operand = ii.getOperand();
      if (Constant *c = dyn_cast<Constant>(operand)) {
        // PASS
      } else {
        kgepi->indices.clear();
      }
    }
    index++;
  }
  kgepi->offset = 0;
}
/// IVAN ADDITIONS END

template <typename TypeIt>
void Executor::computeOffsets(KGEPInstruction *kgepi, TypeIt ib, TypeIt ie) {
  ref<ConstantExpr> constantOffset =
    ConstantExpr::alloc(0, Context::get().getPointerWidth());
  uint64_t index = 1;
  for (TypeIt ii = ib; ii != ie; ++ii) {
    if (LLVM_TYPE_Q StructType *st = dyn_cast<StructType>(*ii)) {
      const StructLayout *sl = kmodule->targetData->getStructLayout(st);
      const ConstantInt *ci = cast<ConstantInt>(ii.getOperand());
      uint64_t addend = sl->getElementOffset((unsigned) ci->getZExtValue());
      constantOffset = constantOffset->Add(ConstantExpr::alloc(addend,
                                                               Context::get().getPointerWidth()));
    } else {
      const SequentialType *set = cast<SequentialType>(*ii);
      uint64_t elementSize = 
        kmodule->targetData->getTypeStoreSize(set->getElementType());
      Value *operand = ii.getOperand();
      if (Constant *c = dyn_cast<Constant>(operand)) {
        ref<ConstantExpr> index = 
          evalConstant(c)->SExt(Context::get().getPointerWidth());
        ref<ConstantExpr> addend = 
          index->Mul(ConstantExpr::alloc(elementSize,
                                         Context::get().getPointerWidth()));
        constantOffset = constantOffset->Add(addend);
      } else {
        kgepi->indices.push_back(std::make_pair(index, elementSize));
      }
    }
    index++;
  }
  kgepi->offset = constantOffset->getZExtValue();
}

void Executor::bindInstructionConstants(KInstruction *KI) {
  KGEPInstruction *kgepi = static_cast<KGEPInstruction*>(KI);

  if (GetElementPtrInst *gepi = dyn_cast<GetElementPtrInst>(KI->inst)) {
    ///IVAN ADDITIONS BEGIN
    clearOffsets(kgepi, gep_type_begin(gepi), gep_type_end(gepi));
    ///IVAN ADDITIONS END
    computeOffsets(kgepi, gep_type_begin(gepi), gep_type_end(gepi));
  } else if (InsertValueInst *ivi = dyn_cast<InsertValueInst>(KI->inst)) {
    computeOffsets(kgepi, iv_type_begin(ivi), iv_type_end(ivi));
    assert(kgepi->indices.empty() && "InsertValue constant offset expected");
  } else if (ExtractValueInst *evi = dyn_cast<ExtractValueInst>(KI->inst)) {
    computeOffsets(kgepi, ev_type_begin(evi), ev_type_end(evi));
    assert(kgepi->indices.empty() && "ExtractValue constant offset expected");
  }
}

void Executor::bindModuleConstants() {
  for (std::vector<KFunction*>::iterator it = kmodule->functions.begin(), 
         ie = kmodule->functions.end(); it != ie; ++it) {
    KFunction *kf = *it;
    for (unsigned i=0; i<kf->numInstructions; ++i)
      bindInstructionConstants(kf->instructions[i]);
  }

  kmodule->constantTable = new Cell[kmodule->constants.size()];
  for (unsigned i=0; i<kmodule->constants.size(); ++i) {
    Cell &c = kmodule->constantTable[i];
    c.value = evalConstant(kmodule->constants[i]);
  }
}


bool Executor::state_complies_with_fsummary1(ExecutionState *state)
{
  StackFrame &sf = state->stack.back();
  path_summary_ty *cur_fsummary = sf.cur_fsummary;
  //assert(cur_fsummary && "DEBUG ASSERT: replace for returning true");
  /* The only case when a suppl call's connected fsummary is NULL is
   * when we deliberately decided not to explore it. In this case we
   * do all forking stuff for this function */
  if(!cur_fsummary)
  {
    llvm::outs() << "Executor::state_complies_with_fsummary1(): cur_fsummary is NULL => returning true\n";
    return true; 
  }
  unsigned index = sf.path_instructions.size() - 1;
  llvm::outs() << "Executor::state_complies_with_fsummary1(): comparing " << *(sf.path_instructions[index]) <<
                  " and " << *(cur_fsummary->path_instructions[index]) << "\n";
  llvm::outs() << "Executor::state_complies_with_fsummary1(): this is instruction " << index+1 << " out of " <<
                  cur_fsummary->path_instructions.size() << "\n";
  if(sf.path_instructions[index] == cur_fsummary->path_instructions[index])
  {
    llvm::outs() << "Executor::state_complies_with_fsummary1(): returning true\n";
    return true;
  }
    llvm::outs() << "Executor::state_complies_with_fsummary1(): returning false\n";
  return false;
}

bool Executor::state_complies_with_fsummary(ExecutionState *state)
{
  llvm::outs() << "Executor::state_complies_with_fsummary(): inside\n";
  StackFrame &sf = state->stack.back();
  path_summary_ty *cur_fsummary = sf.cur_fsummary;
  unsigned num_of_constraints = sf.num_of_constraints;
  //print_function_summary(cur_fsummary);
  if(num_of_constraints == 0)
    return true;
  llvm::outs() << "Executor::state_complies_with_fsummary(): getting constraints\n";
  assert(cur_fsummary && "cur_fsummary is NULL");

  ConstraintManager::constraint_iterator it1 = state->constraints.end(); 
  ConstraintManager::constraint_iterator it2 = cur_fsummary->path_constraints_globals_only.begin();

  for(unsigned i = 0; i<num_of_constraints; i++)
    --it1;



  static unsigned id = 0;
  unsigned w = 32;
  const Array *array = Array::CreateArray("tmp_" + llvm::utostr(id), Expr::getMinBytesForWidth(w) );
  id++;
  ref<Expr> tmp = Expr::createTempRead(array, w);


  for(unsigned i = 0; i<num_of_constraints; i++)
  {
    const ref<Expr> &cond_from_state = *it1;
    const ref<Expr> &cond_from_fsummary = *it2;
    llvm::outs() << "Executor::state_complies_with_fsummary(): considering the follwoign pair:\n"
                 << cond_from_state << "\n and\n" << cond_from_fsummary << "\n";

    std::vector<ref<Expr> > vexpr;
    vexpr.push_back(cond_from_state);
    vexpr.push_back(cond_from_fsummary);
    if(!conds_are_solvable(tmp, &vexpr))
    {
      llvm::outs() << "Executor::state_complies_with_fsummary(): returning false\n";
      return false;
    }
    ++it1;
    ++it2;
  }

  llvm::outs() << "Executor::state_complies_with_fsummary(): returning true\n";
  return true;
}


/* *** State pruning routines start *** */

/* Check if it is time to do state pruning.
 *
 * First check if the current function is not blacklisted for pruning.
 * Second, check if we are at the start of a basic block in case of BB
 * pruning frequency.
 *
 * @param state Current instruction
 * @return true if it is time to check the current state for duplicates.
 *         false otherwise */
bool Executor::isStateMergeTime(KInstruction *ki)
{
	Function * fun = ki->inst->getParent()->getParent();

  /* If the current function is blacklisted, don't do pruning */
	if (mergeBlacklist.find(fun) != mergeBlacklist.end())
  {
		std::string error = "in Blacklisted fun " + fun->getName().str();
		return false;
	}
  
	if (MergeFrequency == InstructionFreq)
		return true;

  /* Get the first instruction of the current basic block */
  llvm::Instruction * instr = ki->inst->getParent()->getFirstNonPHI();
	if ( (MergeFrequency == BBLFreq) && (instr == ki->inst))
  {
    //llvm::outs() << "Executor:::isStateMergeTime(): MergeFreq = BBL; we are at the head; returning true\n";
    return true;
  }

  /* IP: do we really need this check? */
	/*if (MergeFrequency =! NeverFreq)
  {
		outs() << "Instruction freq\n";
		klee_error("ERROR");
	}*/

  return false;
}

/* Hardcode some function for which we don't want to do state pruning 
 *
 * Currently we blacklist 'memset()' and 'memcpy()'
 * IP: don't know why, ask Drew Davidson. */
void Executor::initializeMergeBlackList()
{
  Module::iterator fEnd = kmodule->module->end();
  for (Module::iterator fItr = kmodule->module->begin(); fItr != fEnd ; ++fItr)
  {
    Function * fun = fItr;
    if (fun->getName() == "memset")
      mergeBlacklist.insert(fun);
    if (fun->getName() == "memcpy")
      mergeBlacklist.insert(fun);
  }
}

/* Check if <state>'s memory configuration conincides with a prevously saved
 * configuration.
 *
 * @param state Check this Execution state
 * @param ki    State's current instruction (TODO: we can extract it from the state)
 * @return True if equivalent memory config is found
 *         False otherwise
 */
bool Executor::isDuplicateState(ExecutionState& state, KInstruction *ki)
{
  assert(state.pc && "Instruction pointer cannot be NULL for a state.");
  Instruction * inst = ki->inst;

#if 0
  std::string srcFile = ki->info->file;
  if (srcFile.length() > 42){
  	srcFile = srcFile.substr(42);
  }
  llvm::outs() << "checking duplicates just-before " << *inst << " " 
               << inst->getParent()->getParent()->getName() << "\n"
               << "\t(assembly line: " << ki->info->assemblyLine << ")\n"
               << "\t(source line: " << ki->info->line << " of " 
               << srcFile << ")\n"
               << "\t(id: " << ki->info->id << ")\n";
#endif

	// state.path.push_back(ki);  ---> we will use state.path_instructions

  /*llvm::outs() << "Executor::isDuplicateState(): enter checkDuplicateState\n";
  llvm::outs() << "Executor::isDuplicateState(): There are " << allSavedConfigs.size() << " indices\n";*/
  
  //state.printRegs();
 
  /* Do we have any saved memory configuration for the current instruction? */
  if (allSavedConfigs.find(inst) == allSavedConfigs.end())
  {
    SavedConfig * savedConfig = new SavedConfig(state);
    ConfList * confList = new ConfList(savedConfig);
    allSavedConfigs[inst] = (confList);
    //llvm::outs() << "Executor::isDuplicateState(): No memory config for the current instruction. Adding new memory config.\n";
    return false;
  }

  /* We have saved memory configuration for the current instruction, let's check it
     more detail */
  //llvm::outs() << "Executor::isDuplicateState(): Not adding new memory config\n";
  ConfList * confList = allSavedConfigs[inst];
  unsigned points = confList->size();
  //llvm::outs() << "Executor::isDuplicateState(): points = " << points << "\n";
  //outs() << "THERE ARE " << points << " states at this idx\n";
  bool prunable;
  //SavedConfig * diff = confList->diff(state, smudge, prunable);
  SavedConfig * diff = confList->diff(state, prunable);

  /* We have matching configuration => we can try to get rid of this state */
  if (prunable)
  {
    llvm::outs() << "actual MERGE SUCCESSFUL\n";
    stats::prunes += 1;

#if 0 /* TODO: Why do we ever need this code below? Just delete it! */
    int count = 0;
    for (std::set<ExecutionState*>::iterator it = states.begin(), ie = states.end(); it != ie; ++it) 
    {
      count++;
    }
    llvm::outs() << "there are (were)" << count << " states\n";
    
    //lineStats[ki]->mergeCount++;
    
    //state.causeOfTermination = "merge";
    
    bool isBBLhead = false;
    llvm::Instruction * instr = ki->inst->getParent()->getFirstNonPHI();
    if (instr == ki->inst){
    	isBBLhead = true;
    }
    
    std::string outStreamBacker;
    raw_string_ostream outStream(outStreamBacker);
    
    outStream << "merge at " << *inst << " " 
    			 << inst->getParent()->getParent()->getName() << "\n"
    			 << "\t(assembly line: " << ki->info->assemblyLine << ")\n"
    			 << "\t(source line: " << ki->info->line << " of " 
    			 << ki->info->file << ")\n"
    			 << "\t(id: " << ki->info->id << ")\n"
    			 << "\tisBBLhead" << isBBLhead << "\n";
    std::string outStreamResult = outStream.str();
    interpreterHandler->getInfoStream() << outStreamResult;
 #endif 
    
    return true;
  }
  //llvm::outs() << "MERGE FAILED\n";
  return false;
} 
/* *** State pruning routines end *** */


/* *** Interrupts routines start *** */

/* Create a new execution state which will start executing interrupt
 * handler <iFun>.
 *
 * Create a new execution state based on <state> which will start
 * executing interrupt handler <iFun> and then return to <state>'s
 * current instruction. 
 *
 * @param state Original state
 * @param iFun Interrupt handler
 * @param ki original state's current instruction
 * @return new execution state which executes iFun
 */
ExecutionState* Executor::interruptFork(ExecutionState *state, const Function *iFun, KInstruction *ki)
{
	Function * interruptFun = (Function *)iFun;

	//Spawn the new state
	ExecutionState * interruptState = state->branch();
	//interruptState->parent_id = state->string_id;
	//interruptState->string_id = ++maxId;
	//errs() << "Executor::interruptFork(): State " << state->string_id << " produced fork state ==> " << interruptState->string_id << "\n";
  llvm::outs() << "Executor::interruptFork(): original state " << state << " ==> " << interruptState << " (fork)\n";
	//interruptState->causeOfExistance = std::string("ISR ") + interruptFun->getName().str();
	interruptState->interrupt_depth++;
	assert(interruptState != NULL);

	//TODO: fixme and propagate constness throughout
	interruptState->interruptFun = (Function *)interruptFun;
	addedStates.insert(interruptState);

	state->ptreeNode->data = 0;
	//std::string split_reason = "interrupt " + interruptFun->getName().str();
	//std::pair<PTree::Node*, PTree::Node*> res =
	//	processTree->split(state->ptreeNode, interruptState, state, split_reason);
	std::pair<PTree::Node*, PTree::Node*> res =
		processTree->split(state->ptreeNode, interruptState, state);
	interruptState->ptreeNode = res.first;
	state->ptreeNode = res.second;

	llvm::outs() << "Spawn interrupt " << interruptFun->getName() << "\n";

	/* The use of prevPC actually causes a problem for ESE. If the instruction just
	 * executed is a call from A to B, then the end of the interrupt should return to 
	 * the beginning of B. However, the interrupt will actually return to the
	 * callsite in A, then advance the PC forward so it will work as if the call to
	 * B never happened. */
  llvm::outs() << "Function on executeCall " << *ki->inst << "\n";
	KFunction *kf = kmodule->functionMap[interruptFun];
  llvm::outs() << "PC is at\n";
	llvm::outs() << "\t" << *interruptState->pc->inst << "\n";
	llvm::outs() << "\t" << " of function " << interruptState->pc->inst->getParent()->getParent()->getName() << "\n";
	llvm::outs() << "\t" << "prevPC is at\n";
	llvm::outs() << "\t" << *interruptState->prevPC->inst << "\n";
	llvm::outs() << "\t" << "   of function " << interruptState->prevPC->inst->getParent()->getParent()->getName() << "\n";
	
	bool prevOpcode = interruptState->prevPC->inst->getOpcode();

	KInstIterator restorePC;
	int blah;
	switch (prevOpcode)
  {
	  case Instruction::Call:	
	  case Instruction::Ret:	
	  case Instruction::Br:
      restorePC = interruptState->pc;
      interruptState->pushFrame(interruptState->prevPC, interruptState->pc, kf);
      break;
	  default:
      outs() << "will not restore to special pc\n";
      restorePC = interruptState->prevPC;
      ++restorePC;
      interruptState->pushFrame(interruptState->prevPC, restorePC, kf);
      break;
	}
	
	//interruptState->pushFrame(interruptState->prevPC, ++interruptState->prevPC, kf);
	interruptState->pc = kf->instructions;
  llvm::outs() << "setting pc to the isntrs of " << kf->function->getName() << "\n";
	llvm::outs() << "PC is " << *interruptState->pc->inst << "\n";
	return interruptState;
}



/* Try to execute each interrupt handler found in the user's code (e.g.
 * ADC10_ISR)
 *
 * This function iterates over interrupt handlers found in the analyzed
 * program. If interrupt handler's gate function returns true, the
 * state forks and the new state start executing the ISR.
 *
 * @param state Current execution state
 * @param inst State's current instruction
 * @return void
 */ 
void Executor::executeInterrupts(ExecutionState * state, KInstruction * inst)
{
  llvm::outs() << "Executor::executeInterrupts(): Check Interrupts\n";

	if (state->interruptFun == NULL)
		llvm::outs() << "Executor::executeInterrupts(): not currently in interrupt\n";
	else 
  {
		llvm::outs() << "Executor::executeInterrupts(): interrupt fun addr "  << state->interruptFun << "\n";
		llvm::outs() << "Executor::executeInterrupts(): interrupt fun is " << state->interruptFun->getName() << "\n";
	}

	bool someInterruptOccured = false;
	std::string interruptsFired = "";
  /* Iterate over all interruption handerls found in the user's code.
   * (this list is built in the arch's constructor) */
	InterruptVector::iterator seek = arch->interruptVector.begin();
	InterruptVector::iterator end = arch->interruptVector.end();
	for ( ; seek != end ; ++seek)
  {

		InterruptHandler * handler = *seek;
		//interrupt_gate& interruptCondition = handler->gate;
    llvm::outs() << "Executor::executeInterrupts(): check interrupt " << handler->fun->getName() << "\n";
		//if (interruptCondition == NULL)
		if (handler->gate == NULL)
			klee_error("Absentee interrupt condition (probably a bug in the memory layout file)\n");
    assert(handler->fun);
		//bool interruptEnabled = interruptCondition(arch, state);
		//bool interruptEnabled = handler->gate(arch, state);
		//if (interruptEnabled){
		//	llvm::outs() << "will execute\n";
		//} else {
		//	llvm::outs() << "will not execute\n";
		//}

		//if (interruptEnabled)
		bool same_interrupt = (handler->fun == state->interruptFun); /* We do not suport nested
                                                                    interrupts of the same kind (e.g. ADC10_ISR from ADC10_ISR)*/
    if(!same_interrupt && (handler->gate(arch, state)) ) /* This checks status register and periph registers
                                                            flags (e.g. GIE flag, ADC10IE flag, etc) */
    {
			someInterruptOccured = true;
			//const Function *isr = handler->fun;
			//interruptsFired += std::string(llvm::utostr(maxId + 1)) + " : " + isr->getName().str() + "\n";
			ExecutionState *interrupt_state = interruptFork(state, handler->fun, inst);
			int max_interrupt_depth = 17; /* I love magic numbers */
			if(interrupt_state->interrupt_depth >= max_interrupt_depth)
			{
        llvm::outs() << "Executor::executeInterrupts(): Killing "
                     << "the interrupt_state: too many interrupts: "
                     << interrupt_state->interrupt_depth << "\n";
        terminateStateEarly(*interrupt_state, "Max interrupt depth reached.");
			}
			//++stats::firedInterruptions;
		}
	}
	if (someInterruptOccured)
  {
		//std::string reason = std::string("ISR\n") + interruptsFired;
		//state->treeDump(*mergeTree, reason);
		state->path_instructions.clear();
		//state->parent_id = state->string_id;
		//state->string_id = ++maxId;
		//state->causeOfExistance = "no ISR";
    llvm::outs() << "IVAN: State " << state << " produced an interruptFork and will be terminated\n";
		//llvm::outs() << "STATE: ~" << state->string_id << " (no fork)\n";
		//errs() << "IVAN: State " << state->string_id << " gave life to an interrupt and will be terminated\n";
		terminateStateEarly(*state, "Produced interrupt.");
	        //errs() << "stats::forks = " << stats::forks << "\n";
	        //errs() << "depth" << state->depth << "\n";
		//errs() << " ** There are " << states.size() << " states remaining\n";
	}
	//errs() << "end Check Interrupt\n";
}


/* *** Interrupts routines end *** */

void Executor::run(ExecutionState &initialState) {
  //fprintf(stderr, "IVAN: Inside Executor::run\n");
  bindModuleConstants();

  // Delay init till now so that ticks don't accrue during
  // optimization and such.
  initTimers();

  llvm::Function *start_func = initialState.pc->inst->getParent()->getParent();
  states.insert(&initialState);

  if (usingSeeds) {
    std::vector<SeedInfo> &v = seedMap[&initialState];
    
    for (std::vector<KTest*>::const_iterator it = usingSeeds->begin(), 
           ie = usingSeeds->end(); it != ie; ++it)
      v.push_back(SeedInfo(*it));

    int lastNumSeeds = usingSeeds->size()+10;
    double lastTime, startTime = lastTime = util::getWallTime();
    ExecutionState *lastState = 0;
    while (!seedMap.empty()) {
      if (haltExecution) goto dump;

      std::map<ExecutionState*, std::vector<SeedInfo> >::iterator it = 
        seedMap.upper_bound(lastState);
      if (it == seedMap.end())
        it = seedMap.begin();
      lastState = it->first;
      unsigned numSeeds = it->second.size();
      ExecutionState &state = *lastState;
      KInstruction *ki = state.pc;
      stepInstruction(state);

      executeInstruction(state, ki);
      processTimers(&state, MaxInstructionTime * numSeeds);
      updateStates(&state);

      if ((stats::instructions % 1000) == 0) {
        int numSeeds = 0, numStates = 0;
        for (std::map<ExecutionState*, std::vector<SeedInfo> >::iterator
               it = seedMap.begin(), ie = seedMap.end();
             it != ie; ++it) {
          numSeeds += it->second.size();
          numStates++;
        }
        double time = util::getWallTime();
        if (SeedTime>0. && time > startTime + SeedTime) {
          klee_warning("seed time expired, %d seeds remain over %d states",
                       numSeeds, numStates);
          break;
        } else if (numSeeds<=lastNumSeeds-10 ||
                   time >= lastTime+10) {
          lastTime = time;
          lastNumSeeds = numSeeds;          
          klee_message("%d seeds remaining over: %d states", 
                       numSeeds, numStates);
        }
      }
    }

    klee_message("seeding done (%d states remain)", (int) states.size());

    // XXX total hack, just because I like non uniform better but want
    // seed results to be equally weighted.
    for (std::set<ExecutionState*>::iterator
           it = states.begin(), ie = states.end();
         it != ie; ++it) {
      (*it)->weight = 1.;
    }

    if (OnlySeed)
      goto dump;
  }

  searcher = constructUserSearcher(*this);

  searcher->update(0, states, std::set<ExecutionState*>());

  /// IVAN ADDITIONS BEGIN
  //searcher->set_path_instructions(path_instructions);
  searcher->set_path_functions(path_functions);
  searcher->set_cfg_paths(cfg_paths);
  searcher->set_path(path);
  searcher->rand_search_freq = rand_search_freq;
  searcher->prefer_short_summaries = prefer_short_summaries;
  /// IVAN ADDITIONS END

  //int ivan_i = 0;
  while (!states.empty() && !haltExecution && !comp_symbex_target_reached) {
    ExecutionState &state = searcher->selectState();
    llvm::outs() << "Selected state " << &state << " (pathDeviationDepth = " << state.pathDeviationDepth << ")\n\n";
#if 0
    std::string constraints;
    getConstraintLog(state, constraints, KQUERY);
    llvm::outs() << "                           constraints for the state: \n" << constraints;
#endif

    KInstruction *ki = state.pc;

    /// IVAN ADDITIONS BEGIN
    Instruction *instr = ki->inst;
    std::string instr_str;
    raw_string_ostream str_stream(instr_str);                                 
    str_stream << *instr;
    state.path_choices_debug.push_back(instr_str);
    state.path_instructions.push_back(instr);
    state.stack.back().path_instructions.push_back(instr);

    /* If we are in "building function summaries" mode */
    if(!forward_symbex) 
    {
      llvm::Function *cur_func = instr->getParent()->getParent();

      /* If we collect enough path summaries, stop backward symbex */
      if((good_path_summaries[cur_func].size() >= 10) && (time(NULL) - build_fsummary_start_timer >= 5))
      {
        llvm::outs() << "Executor::run(): we collected the minimum number of call path summaries for " << cur_func->getName() << ". Stopping the run\n";
        llvm::outs() << "Executor::run(): number of good path summaries = " << good_path_summaries[cur_func].size() << "\n";
        for(unsigned i = 0; i<good_path_summaries[cur_func].size(); i++)
          print_function_summary(good_path_summaries[cur_func][i]);
        comp_symbex_target_reached = 1;
        //exit(0);
      }
      /* Check if the current state has a memory configuration that we saw before */
      //else if (PruneMode && shouldMerge(state, ki) && isDuplicateState(state, ki))
      else if (isStateMergeTime(ki) && isDuplicateState(state, ki))
      {
        terminateState(state);
        llvm::outs() << "Executor::run(): terminate STATE\n"; 
      } 
    }
    

#if 0 /* TODO: implement state merging here */
    if(!forward_symbex)
    {
      llvm::outs() << "Executor::run(): Checking if the state can be merged\n";
      if(state_can_be_merged(&state))
      {
        llvm::outs() << "Executor::run(): can be merged with another state in backward symbex\n";
        terminateStateEarly(state, "merge");
        updateStates(&state);
        //exit(0);
        continue;
      }
    }
#endif

    /* If we are in normal forward symbex mode */
    if(forward_symbex)
    {
      bool res = state_complies_with_fsummary1(&state);
      if(res == false)
      {
        llvm::outs() << "Executor::run(): state does now comply with the current fsummary during"
                        " the forward symbex!\n";
        terminateStateEarly(state, "does not comply with fsummary.");
        updateStates(&state);
        continue;
      }
    }
    /// IVAN ADDITIONS END
     
    stepInstruction(state);
    executeInstruction(state, ki);

    if(forward_symbex)
      executeInterrupts(&state, ki);


    processTimers(&state, MaxInstructionTime);

    if (MaxMemory) {
      //fprintf(stderr, "IVAN: inside MaxMemory0\n");
      if ((stats::instructions & 0xFFFF) == 0) {
        //fprintf(stderr, "IVAN: inside MaxMemory1\n");
        // We need to avoid calling GetMallocUsage() often because it
        // is O(elts on freelist). This is really bad since we start
        // to pummel the freelist once we hit the memory cap.
        unsigned mbs = util::GetTotalMallocUsage() >> 20;
        if (mbs > MaxMemory) {
          if (mbs > MaxMemory + 100) {
            // just guess at how many to kill
            unsigned numStates = states.size();
            unsigned toKill = std::max(1U, numStates - numStates*MaxMemory/mbs);

            klee_warning("killing %d states (over memory cap)", toKill);

            std::vector<ExecutionState*> arr(states.begin(), states.end());
            for (unsigned i=0,N=arr.size(); N && i<toKill; ++i,--N) {
              unsigned idx = rand() % N;

              // Make two pulls to try and not hit a state that
              // covered new code.
              if (arr[idx]->coveredNew)
                idx = rand() % N;

              std::swap(arr[idx], arr[N-1]);
              terminateStateEarly(*arr[N-1], "Memory limit exceeded.");
            }
          }
          atMemoryLimit = true;
        } else {
          atMemoryLimit = false;
        }
      }
    }

    updateStates(&state);
  }
  if(states.empty())
    should_collect_more_summaries[start_func] = false;
  delete searcher;
  searcher = 0;
  
 dump:
  if (DumpStatesOnHalt && !states.empty()) {
    llvm::errs() << "KLEE: halting execution, dumping remaining states\n";
    for (std::set<ExecutionState*>::iterator
           it = states.begin(), ie = states.end();
         it != ie; ++it) {
      ExecutionState &state = **it;
      stepInstruction(state); // keep stats rolling
      terminateStateEarly(state, "Execution halting.");
    }
    updateStates(0);
  }
}

std::string Executor::getAddressInfo(ExecutionState &state, 
                                     ref<Expr> address) const{
  std::string Str;
  llvm::raw_string_ostream info(Str);
  info << "\taddress: " << address << "\n";
  uint64_t example;
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(address)) {
    example = CE->getZExtValue();
  } else {
    ref<ConstantExpr> value;
    bool success = solver->getValue(state, address, value);
    assert(success && "FIXME: Unhandled solver failure");
    (void) success;
    example = value->getZExtValue();
    info << "\texample: " << example << "\n";
    std::pair< ref<Expr>, ref<Expr> > res = solver->getRange(state, address);
    info << "\trange: [" << res.first << ", " << res.second <<"]\n";
  }
  
  MemoryObject hack((unsigned) example);    
  MemoryMap::iterator lower = state.addressSpace.objects.upper_bound(&hack);
  info << "\tnext: ";
  if (lower==state.addressSpace.objects.end()) {
    info << "none\n";
  } else {
    const MemoryObject *mo = lower->first;
    std::string alloc_info;
    mo->getAllocInfo(alloc_info);
    info << "object at " << mo->guest_address
         << " of size " << mo->size << "\n"
         << "\t\t" << alloc_info << "\n";
  }
  if (lower!=state.addressSpace.objects.begin()) {
    --lower;
    info << "\tprev: ";
    if (lower==state.addressSpace.objects.end()) {
      info << "none\n";
    } else {
      const MemoryObject *mo = lower->first;
      std::string alloc_info;
      mo->getAllocInfo(alloc_info);
      info << "object at " << mo->guest_address 
           << " of size " << mo->size << "\n"
           << "\t\t" << alloc_info << "\n";
    }
  }

  return info.str();
}

void Executor::terminateState(ExecutionState &state) {
  if (replayOut && replayPosition!=replayOut->numObjects) {
    klee_warning_once(replayOut, 
                      "replay did not consume all objects in test input.");
  }

  interpreterHandler->incPathsExplored();

  std::set<ExecutionState*>::iterator it = addedStates.find(&state);
  if (it==addedStates.end()) {
    state.pc = state.prevPC;

    removedStates.insert(&state);
  } else {
    // never reached searcher, just delete immediately
    std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it3 = 
      seedMap.find(&state);
    if (it3 != seedMap.end())
      seedMap.erase(it3);
    addedStates.erase(it);
    processTree->remove(state.ptreeNode);
    delete &state;
  }
}

void Executor::terminateStateEarly(ExecutionState &state, 
                                   const Twine &message) {
  if (!OnlyOutputStatesCoveringNew || state.coveredNew ||
      (AlwaysOutputSeeds && seedMap.count(&state)))
    interpreterHandler->processTestCase(state, (message + "\n").str().c_str(),
                                        "early");
  terminateState(state);
}

void Executor::terminateStateOnExit(ExecutionState &state) {
  llvm::outs() << "terminateStateOnExit(): interpreterHandler = " << interpreterHandler << "\n";
  if (!OnlyOutputStatesCoveringNew || state.coveredNew || 
      (AlwaysOutputSeeds && seedMap.count(&state)))
  {
    llvm::outs() << "terminateStateOnExit(): going inside  interpreterHandler->processTestCase()\n";
    interpreterHandler->processTestCase(state, 0, 0);
  }
  llvm::outs() << "terminateStateOnExit(): going inside terminateState()\n";
  terminateState(state);
}

const InstructionInfo & Executor::getLastNonKleeInternalInstruction(const ExecutionState &state,
    Instruction ** lastInstruction) {
  // unroll the stack of the applications state and find
  // the last instruction which is not inside a KLEE internal function
  ExecutionState::stack_ty::const_reverse_iterator it = state.stack.rbegin(),
      itE = state.stack.rend();

  // don't check beyond the outermost function (i.e. main())
  itE--;

  const InstructionInfo * ii = 0;
  if (kmodule->internalFunctions.count(it->kf->function) == 0){
    ii =  state.prevPC->info;
    *lastInstruction = state.prevPC->inst;
    //  Cannot return yet because even though
    //  it->function is not an internal function it might of
    //  been called from an internal function.
  }

  // Wind up the stack and check if we are in a KLEE internal function.
  // We visit the entire stack because we want to return a CallInstruction
  // that was not reached via any KLEE internal functions.
  for (;it != itE; ++it) {
    // check calling instruction and if it is contained in a KLEE internal function
    const Function * f = (*it->caller).inst->getParent()->getParent();
    if (kmodule->internalFunctions.count(f)){
      ii = 0;
      continue;
    }
    if (!ii){
      ii = (*it->caller).info;
      *lastInstruction = (*it->caller).inst;
    }
  }

  if (!ii) {
    // something went wrong, play safe and return the current instruction info
    *lastInstruction = state.prevPC->inst;
    return *state.prevPC->info;
  }
  return *ii;
}
void Executor::terminateStateOnError(ExecutionState &state,
                                     const llvm::Twine &messaget,
                                     const char *suffix,
                                     const llvm::Twine &info) {
  std::string message = messaget.str();
  static std::set< std::pair<Instruction*, std::string> > emittedErrors;
  Instruction * lastInst;
  const InstructionInfo &ii = getLastNonKleeInternalInstruction(state, &lastInst);
  
  if (EmitAllErrors ||
      emittedErrors.insert(std::make_pair(lastInst, message)).second) {
    if (ii.file != "") {
      klee_message("ERROR: %s:%d: %s", ii.file.c_str(), ii.line, message.c_str());
    } else {
      klee_message("ERROR: (location information missing) %s", message.c_str());
    }
    if (!EmitAllErrors)
      klee_message("NOTE: now ignoring this error at this location");

    std::string MsgString;
    llvm::raw_string_ostream msg(MsgString);
    msg << "Error: " << message << "\n";
    if (ii.file != "") {
      msg << "File: " << ii.file << "\n";
      msg << "Line: " << ii.line << "\n";
      msg << "assembly.ll line: " << ii.assemblyLine << "\n";
    }
    msg << "Stack: \n";
    state.dumpStack(msg);

    std::string info_str = info.str();
    if (info_str != "")
      msg << "Info: \n" << info_str;

    interpreterHandler->processTestCase(state, msg.str().c_str(), suffix);
  }
    
  terminateState(state);
}

// XXX shoot me
static const char *okExternalsList[] = { "printf", 
                                         "fprintf", 
                                         "puts",
                                         "getpid" };
static std::set<std::string> okExternals(okExternalsList,
                                         okExternalsList + 
                                         (sizeof(okExternalsList)/sizeof(okExternalsList[0])));

void Executor::callExternalFunction(ExecutionState &state,
                                    KInstruction *target,
                                    Function *function,
                                    std::vector< ref<Expr> > &arguments) {
  // check if specialFunctionHandler wants it
  if (specialFunctionHandler->handle(state, function, target, arguments))
    return;
  llvm::outs() << "DEBUG: passed over special function handler\n";
  
  if (NoExternals && !okExternals.count(function->getName())) {
    llvm::errs() << "KLEE:ERROR: Calling not-OK external function : "
                 << function->getName().str() << "\n";
    terminateStateOnError(state, "externals disallowed", "user.err");
    return;
  }

  // normal external function handling path
  // allocate 128 bits for each argument (+return value) to support fp80's;
  // we could iterate through all the arguments first and determine the exact
  // size we need, but this is faster, and the memory usage isn't significant.
  uint64_t *args = (uint64_t*) alloca(2*sizeof(*args) * (arguments.size() + 1));
  memset(args, 0, 2 * sizeof(*args) * (arguments.size() + 1));
  unsigned wordIndex = 2;
  for (std::vector<ref<Expr> >::iterator ai = arguments.begin(), 
       ae = arguments.end(); ai!=ae; ++ai) {
    if (AllowExternalSymCalls) { // don't bother checking uniqueness
      ref<ConstantExpr> ce;
      bool success = solver->getValue(state, *ai, ce);
      assert(success && "FIXME: Unhandled solver failure");
      (void) success;
      ce->toMemory(&args[wordIndex]);
      wordIndex += (ce->getWidth()+63)/64;
    } else {
      ref<Expr> arg = toUnique(state, *ai);
      if (ConstantExpr *ce = dyn_cast<ConstantExpr>(arg)) {
        // XXX kick toMemory functions from here
        ce->toMemory(&args[wordIndex]);
        wordIndex += (ce->getWidth()+63)/64;
      } else {
        terminateStateOnExecError(state, 
                                  "external call with symbolic argument: " + 
                                  function->getName());
        return;
      }
    }
  }

  state.addressSpace.copyOutConcretes();

  if (!SuppressExternalWarnings) {

    std::string TmpStr;
    llvm::raw_string_ostream os(TmpStr);
    os << "calling external: " << function->getName().str() << "(";
    for (unsigned i=0; i<arguments.size(); i++) {
      os << arguments[i];
      if (i != arguments.size()-1)
	os << ", ";
    }
    os << ")";
    
    if (AllExternalWarnings)
      klee_warning("%s", os.str().c_str());
    else
      klee_warning_once(function, "%s", os.str().c_str());
  }
  
  bool success = externalDispatcher->executeCall(function, target->inst, args);
  if (!success) {
    terminateStateOnError(state, "failed external call: " + function->getName(),
                          "external.err");
    return;
  }

  if (!state.addressSpace.copyInConcretes()) {
    terminateStateOnError(state, "external modified read-only object",
                          "external.err");
    return;
  }

  LLVM_TYPE_Q Type *resultType = target->inst->getType();
  if (resultType != Type::getVoidTy(getGlobalContext())) {
    ref<Expr> e = ConstantExpr::fromMemory((void*) args, 
                                           getWidthForLLVMType(resultType));
    bindLocal(target, state, e);
  }
}

/***/

ref<Expr> Executor::replaceReadWithSymbolic(ExecutionState &state, 
                                            ref<Expr> e) {
  unsigned n = interpreterOpts.MakeConcreteSymbolic;
  if (!n || replayOut || replayPath)
    return e;

  // right now, we don't replace symbolics (is there any reason to?)
  if (!isa<ConstantExpr>(e))
    return e;

  if (n != 1 && random() % n)
    return e;

  // create a new fresh location, assert it is equal to concrete value in e
  // and return it.
  
  static unsigned id;
  const Array *array = Array::CreateArray("rrws_arr" + llvm::utostr(++id),
					  Expr::getMinBytesForWidth(e->getWidth()));
  ref<Expr> res = Expr::createTempRead(array, e->getWidth());
  ref<Expr> eq = NotOptimizedExpr::create(EqExpr::create(e, res));
  llvm::errs() << "Making symbolic: " << eq << "\n";
  state.addConstraint(eq);
  return res;
}



/* Allocate new memory with malloc. Find a free memory chunk of size
 * <size> in the state's address space and mark it reserved.
 *
 * We first use malloc() to allocate the memory on the host (this is the
 * where we will actually store the data). We then need to map this
 * memory on the guest: we iterate over state->addressSpace.objects
 * guest_addresses and try to find a free memory region of size bigger
 * then <size> We don't differentiate between the heap and the stack: we
 * put everything into one big chunk 
 *
 * @param size Size of the new memory to allcoate
 * @param state The state Address Space of which we consider
 *
 * @return pointer to the start of available memory address on the guest
 */
uint64_t Executor::get_free_memchunk_at_guest(unsigned size, ExecutionState *state) 
{
  if (size>10*1024*1024)
  {
    klee_warning_once(0, "failing large alloc: %u bytes", (unsigned) size);
    return 0;
  }
  
  uint16_t heap_min = 0x8000;
  assert(state);

#if 0
  llvm::outs() << " working with state "  << state << "\n";
  llvm::outs() << " Allocation memory max is " << arch->memory_size - 1 << "\n";
  llvm::outs() << " Attempting allocation of " << size << "\n";
#endif

  /* Now we need to find a free memory chunk at the guest
   * Note that state->addressSpace.objects is a map of memory objects 
   * sorted by guest_address (see AddressSpace.h) */
  MemoryMap::iterator obj_begin = state->addressSpace.objects.begin();
  MemoryMap::iterator obj_end = state->addressSpace.objects.end();
  unsigned prev_begin = 0;
  unsigned cur_end = 0;
  //llvm::outs() << " Going to allocate" <<
  //  " space for a new object of size " << size << ". " <<
  //  "state->addressSpace.objects.size() = " <<
  //  state->addressSpace.objects.size() << "\n";
  uint64_t guest_address;
  bool first = false;

  /* If we don't have any objects yet, reserve space at the
   * highest memory address */
  if (obj_begin == obj_end) 
  {
    guest_address = arch->memory_size - 1 - size;
    //std::cout << " This is the first memory object. guest addr: "  << guest_address << "\n";
    //std::cout << " arch->memory_size =  "  << arch->memory_size << "\n";
    first = true;
  }
  /* Else iterate through objects from the end: i.e from highest to lowest memory address */
  else 
  {
    const MemoryObject *obj = NULL;
    --obj_end; // Now it points to the latest object (at highest memory location)
    obj = obj_end->first;
    prev_begin = obj->guest_address;
    //llvm::outs() << " We have object at [" << obj->guest_address << "-" << obj->guest_address + obj->size << "]\n";
    while (obj_begin != obj_end)
    {
      --obj_end; // Going from the end
      obj = obj_end->first;
      //const MemoryObject *obj = obj_end->first;
      cur_end = obj->guest_address + obj->size;

      //llvm::outs() << " We have object at [" << obj->guest_address << "-" << obj->guest_address + obj->size << "]\n";
      //llvm::outs() << " cur end " << cur_end << " prev begin " << prev_begin << "\n";

      if ( (prev_begin - size >= cur_end) && (cur_end + size < arch->memory_size) )
      {
        guest_address = prev_begin - size;
        //llvm::outs() << " There was an appropriate memory gap\n";
	  		//llvm::outs() << " updated address is " << guest_address << "\n";
        break;
      } 
      prev_begin = obj->guest_address;
    }
  }

  /* We reached the wilderness */
  if (!first && obj_begin == obj_end)
  {
    //llvm::outs() << " extending guest memory past the last object\n";
    guest_address = prev_begin - size;
  }

  llvm::outs() << " Found apporpriate memory chunk:  ++ [" << guest_address << " - " << guest_address+size << "]\n";

  if (guest_address < 1000)
    llvm::outs() << "MemoryManager::allocate_guest(): Guest address seems to be too low\n";

  return guest_address;
}

ObjectState *Executor::bindObjectInState(ExecutionState &state, 
                                         const MemoryObject *mo,
                                         bool isLocal,
                                         const Array *array) {
  /// IVAN ADDITIONS BEGIN
  /* <guest_address> is set in case the memory object was allocated with allocateFixed(),
   * it is 0 otherwise */
  if(!(mo->guest_address))
    ((MemoryObject *)mo)->guest_address = get_free_memchunk_at_guest(mo->size, &state);
  /// IVAN ADDITIONS END
  
  ObjectState *os = array ? new ObjectState(mo, array) : new ObjectState(mo);
  state.addressSpace.bindObject(mo, os);

  // Its possible that multiple bindings of the same mo in the state
  // will put multiple copies on this list, but it doesn't really
  // matter because all we use this list for is to unbind the object
  // on function return.
  if (isLocal)
    state.stack.back().allocas.push_back(mo);

  return os;
}

void Executor::executeAlloc(ExecutionState &state,
                            ref<Expr> size,
                            bool isLocal,
                            KInstruction *target,
                            bool zeroMemory,
                            const ObjectState *reallocFrom) {
  size = toUnique(state, size);
  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(size)) {
    MemoryObject *mo = memory->allocate(CE->getZExtValue(), isLocal, false, 
                                        state.prevPC->inst);
    if (!mo) {
      bindLocal(target, state, 
                ConstantExpr::alloc(0, Context::get().getPointerWidth()));
    } else {
      ObjectState *os = bindObjectInState(state, mo, isLocal);
      if (zeroMemory) {
        os->initializeToZero();
      } else {
        os->initializeToRandom();
      }
      bindLocal(target, state, mo->getBaseExpr());
      
      if (reallocFrom) {
        unsigned count = std::min(reallocFrom->size, os->size);
        for (unsigned i=0; i<count; i++)
          os->write(i, reallocFrom->read8(i));
        state.addressSpace.unbindObject(reallocFrom->getObject());
      }
    }
  } else {
    // XXX For now we just pick a size. Ideally we would support
    // symbolic sizes fully but even if we don't it would be better to
    // "smartly" pick a value, for example we could fork and pick the
    // min and max values and perhaps some intermediate (reasonable
    // value).
    // 
    // It would also be nice to recognize the case when size has
    // exactly two values and just fork (but we need to get rid of
    // return argument first). This shows up in pcre when llvm
    // collapses the size expression with a select.

    ref<ConstantExpr> example;
    bool success = solver->getValue(state, size, example);
    assert(success && "FIXME: Unhandled solver failure");
    (void) success;
    
    // Try and start with a small example.
    Expr::Width W = example->getWidth();
    while (example->Ugt(ConstantExpr::alloc(128, W))->isTrue()) {
      ref<ConstantExpr> tmp = example->LShr(ConstantExpr::alloc(1, W));
      bool res;
      bool success = solver->mayBeTrue(state, EqExpr::create(tmp, size), res);
      assert(success && "FIXME: Unhandled solver failure");      
      (void) success;
      if (!res)
        break;
      example = tmp;
    }

    StatePair fixedSize = fork(state, EqExpr::create(example, size), true);
    
    if (fixedSize.second) { 
      // Check for exactly two values
      ref<ConstantExpr> tmp;
      bool success = solver->getValue(*fixedSize.second, size, tmp);
      assert(success && "FIXME: Unhandled solver failure");      
      (void) success;
      bool res;
      success = solver->mustBeTrue(*fixedSize.second, 
                                   EqExpr::create(tmp, size),
                                   res);
      assert(success && "FIXME: Unhandled solver failure");      
      (void) success;
      if (res) {
        executeAlloc(*fixedSize.second, tmp, isLocal,
                     target, zeroMemory, reallocFrom);
      } else {
        // See if a *really* big value is possible. If so assume
        // malloc will fail for it, so lets fork and return 0.
        StatePair hugeSize = 
          fork(*fixedSize.second, 
               UltExpr::create(ConstantExpr::alloc(1<<31, W), size), 
               true);
        if (hugeSize.first) {
          klee_message("NOTE: found huge malloc, returning 0");
          bindLocal(target, *hugeSize.first, 
                    ConstantExpr::alloc(0, Context::get().getPointerWidth()));
        }
        
        if (hugeSize.second) {

          std::string Str;
          llvm::raw_string_ostream info(Str);
          ExprPPrinter::printOne(info, "  size expr", size);
          info << "  concretization : " << example << "\n";
          info << "  unbound example: " << tmp << "\n";
          terminateStateOnError(*hugeSize.second, 
                                "concretized symbolic size", 
                                "model.err", 
                                info.str());
        }
      }
    }

    if (fixedSize.first) // can be zero when fork fails
      executeAlloc(*fixedSize.first, example, isLocal, 
                   target, zeroMemory, reallocFrom);
  }
}

void Executor::executeFree(ExecutionState &state,
                           ref<Expr> address,
                           KInstruction *target) {
  StatePair zeroPointer = fork(state, Expr::createIsZero(address), true);
  if (zeroPointer.first) {
    if (target)
      bindLocal(target, *zeroPointer.first, Expr::createPointer(0));
  }
  if (zeroPointer.second) { // address != 0
    ExactResolutionList rl;
    resolveExact(*zeroPointer.second, address, rl, "free");
    
    for (Executor::ExactResolutionList::iterator it = rl.begin(), 
           ie = rl.end(); it != ie; ++it) {
      const MemoryObject *mo = it->first.first;
      if (mo->isLocal) {
        terminateStateOnError(*it->second, 
                              "free of alloca", 
                              "free.err",
                              getAddressInfo(*it->second, address));
      } else if (mo->isGlobal) {
        terminateStateOnError(*it->second, 
                              "free of global", 
                              "free.err",
                              getAddressInfo(*it->second, address));
      } else {
        it->second->addressSpace.unbindObject(mo);
        if (target)
          bindLocal(target, *it->second, Expr::createPointer(0));
      }
    }
  }
}

void Executor::resolveExact(ExecutionState &state,
                            ref<Expr> p,
                            ExactResolutionList &results, 
                            const std::string &name) {
  // XXX we may want to be capping this?
  ResolutionList rl;
  state.addressSpace.resolve(state, solver, p, rl);
  
  ExecutionState *unbound = &state;
  for (ResolutionList::iterator it = rl.begin(), ie = rl.end(); 
       it != ie; ++it) {
    ref<Expr> inBounds = EqExpr::create(p, it->first->getBaseExpr());
    
    StatePair branches = fork(*unbound, inBounds, true);
    
    if (branches.first)
      results.push_back(std::make_pair(*it, branches.first));

    unbound = branches.second;
    if (!unbound) // Fork failure
      break;
  }

  if (unbound) {
    terminateStateOnError(*unbound,
                          "memory error: invalid pointer: " + name,
                          "ptr.err",
                          getAddressInfo(*unbound, p));
  }
}

void Executor::executeMemoryOperation(ExecutionState &state,
                                      bool isWrite,
                                      ref<Expr> address,
                                      ref<Expr> value /* undef if read */,
                                      KInstruction *target /* undef if write */) {
  llvm::outs() << "Executor::executeMemoryOperation() :: inside\n";
  Expr::Width type = (isWrite ? value->getWidth() : 
                     getWidthForLLVMType(target->inst->getType()));
  unsigned bytes = Expr::getMinBytesForWidth(type);

  if (SimplifySymIndices) {
    if (!isa<ConstantExpr>(address))
      address = state.constraints.simplifyExpr(address);
    if (isWrite && !isa<ConstantExpr>(value))
      value = state.constraints.simplifyExpr(value);
  }

  // fast path: single in-bounds resolution
  ObjectPair op;
  bool success;
  solver->setTimeout(coreSolverTimeout);
  llvm::outs() << "Executor::executeMemoryOperation() :: Going inside resolveOne()\n";
  if (!state.addressSpace.resolveOne(state, solver, address, op, success)) {
    address = toConstant(state, address, "resolveOne failure");
    success = state.addressSpace.resolveOne(cast<ConstantExpr>(address), op);
  }
  solver->setTimeout(0);
  llvm::outs() << "Executor::executeMemoryOperation() :: returned from resolveOne()\n";

  if (success) {
    llvm::outs() << "Executor::executeMemoryOperation() :: sucess = true\n";


    /// IVAN ADDITIONS BEGIN We replaced this code with more general Drew's code
    #if 0
    if(target)
    {
      LoadInst *load_inst = dyn_cast<LoadInst>(target->inst);
      if(load_inst)
      {
        llvm::Value *val = load_inst->getPointerOperand();
        llvm::outs() << "Executor::executeMemoryOperation():: load operand = : " << val->getName() << "\n";
        if(val->getName().str() == "ADC10MEM0")
        {
          static unsigned id = 0;
          unsigned w = 16;
          //unsigned w = 10;
          const Array *array = Array::CreateArray(val->getName().str() + "_" + llvm::utostr(id), Expr::getMinBytesForWidth(w) );
          id++;
          ref<Expr> result = Expr::createTempRead(array, w);
          llvm::outs() << "Executor::executeInstruction():Load: replacing 'ADC10MEM0' with a new symbolic variable.\n";
				  bindLocal(target, state, result); // LLVM always loads things into local registers
          
          /* FIXME: Hack, ADC10 is 10 bits, and we cannot create TempRead's with 10 bits, so just add
           * a constraint < 1024 */
          llvm::outs() << "Executor::executeInstruction():Load: hack: adding constraint to the state ADC10MEM0 < 1024.\n";
          ref<Expr> const_1024 =  ConstantExpr::create(1024, Expr::Int16);
          ref<Expr> ult_1024 = UltExpr::create(result, const_1024);
          state.addConstraint(ult_1024);

				  return;
        }
      }
    }
    #endif
    /// IVAN ADDITIONS END. We replaced this code with more general Drew's code


    const MemoryObject *mo = op.first;


    /// DREW ADDITIONS BEGIN
    /* Drew's code below is responsible for handling read/writes to/from
     * special memory location: peripheral registers and flash memroy.
     * For each such location, the code invokes specel read/write
     * handlers which are defined by the Architecture class */
    ConstantExpr * ce = dyn_cast<ConstantExpr>(address);
    /* We don't support accessing special memory locations using
     * symbolic addresses yet */
    if (ce != NULL){
	    uint64_t addrVal = ce->getZExtValue();
	    if (addrVal < arch->memory_size){
		    uint8_t flags = arch->memory[addrVal];
		    if ((flags & MEMORY_SPECIAL) && isWrite){
			    if (flags & MEMORY_FLASH){
				    llvm::outs() << "IS FLASH write at " << addrVal << "\n";
				    return;
			    }

			    special_write_t writeFun = arch->writeMap[addrVal];
			    if (writeFun == NULL){
				    klee_error("Absentee writeFun at 0x%lx\n", addrVal);
			    }
			    bool validWrite = writeFun(&state, addrVal, value, false);
			    if (!validWrite){
				    terminateStateOnError(state,
						    "memory error: invalid peripheral write",
						    "write.err");
			    }
			    return;
		    } else if (flags & MEMORY_SPECIAL){
			    if (flags & MEMORY_FLASH){
				    llvm::outs() << "IS FLASH read at " << addrVal << "\n";
				    ref<Expr> result = arch->flashReader(&state, addrVal, type, false);
				    llvm::outs() << "flash READ" << result << "\n";
				    bindLocal(target, state, result);
				    return;
			    } else {
				    special_read_t readFun = arch->readMap[addrVal];
				    if (readFun == NULL){
					    //klee_error("Absentee readFun at 0x%lx (not flash)\n", addrVal);
					    terminateStateOnError(state,
							    "invalid read",
							    "read.err");
				    }
				    ref<Expr> result;
            if(forward_symbex) // return previosly written value
				      result = readFun(&state, addrVal, type, false);
            else // return fresh symbolics
				      result = readFun(&state, addrVal, type, true);
				    bindLocal(target, state, result);
				    return;
			    }
		    }
	    }
    }
    /// DREW ADDITIONS END

 
    if (MaxSymArraySize && mo->size>=MaxSymArraySize) {
      address = toConstant(state, address, "max-sym-array-size");
    }
    
    ref<Expr> offset = mo->getOffsetExpr(address);

    bool inBounds;
    solver->setTimeout(coreSolverTimeout);
    bool success = solver->mustBeTrue(state, 
                                      mo->getBoundsCheckOffset(offset, bytes),
                                      inBounds);
    solver->setTimeout(0);
    if (!success) {
      state.pc = state.prevPC;
      terminateStateEarly(state, "Query timed out (bounds check).");
      return;
    }

    if (inBounds) {
      const ObjectState *os = op.second;
      if (isWrite) {
        if (os->readOnly) {
          terminateStateOnError(state,
                                "memory error: object read only",
                                "readonly.err");
        } else {
          ObjectState *wos = state.addressSpace.getWriteable(mo, os);
          llvm::outs() << "Executor::executeMemoryOperation() :: sucess (for write) = true; value = " << value << "\n";
          wos->write(offset, value);
        }          
      } else {
        ref<Expr> result = os->read(offset, type);
        
        llvm::outs() << "Executor::executeMemoryOperation() :: sucess (for read) = true; result = " << result << "\n";
        if (interpreterOpts.MakeConcreteSymbolic)
          result = replaceReadWithSymbolic(state, result);

        
        bindLocal(target, state, result);
      }

      return;
    }
  } else
    llvm::outs() << "Executor::executeMemoryOperation() :: sucess = false, going to exit(0)\n";
  
  //exit(0);
  // we are on an error path (no resolution, multiple resolution, one
  // resolution with out of bounds)
  
  ResolutionList rl;  
  solver->setTimeout(coreSolverTimeout);
  bool incomplete = state.addressSpace.resolve(state, solver, address, rl,
                                               0, coreSolverTimeout);
  solver->setTimeout(0);
  
  // XXX there is some query wasteage here. who cares?
  ExecutionState *unbound = &state;
  
  for (ResolutionList::iterator i = rl.begin(), ie = rl.end(); i != ie; ++i) {
    const MemoryObject *mo = i->first;
    const ObjectState *os = i->second;
    ref<Expr> inBounds = mo->getBoundsCheckPointer(address, bytes);
    
    StatePair branches = fork(*unbound, inBounds, true);
    ExecutionState *bound = branches.first;

    // bound can be 0 on failure or overlapped 
    if (bound) {
      if (isWrite) {
        if (os->readOnly) {
          terminateStateOnError(*bound,
                                "memory error: object read only",
                                "readonly.err");
        } else {
          ObjectState *wos = bound->addressSpace.getWriteable(mo, os);
          wos->write(mo->getOffsetExpr(address), value);
        }
      } else {
        ref<Expr> result = os->read(mo->getOffsetExpr(address), type);
        bindLocal(target, *bound, result);
      }
    }

    unbound = branches.second;
    if (!unbound)
      break;
  }
  
  // XXX should we distinguish out of bounds and overlapped cases?
  if (unbound) {
    if (incomplete) {
      terminateStateEarly(*unbound, "Query timed out (resolve).");
    } else {
      terminateStateOnError(*unbound,
                            "memory error: out of bound pointer",
                            "ptr.err",
                            getAddressInfo(*unbound, address));
    }
  }
}

void Executor::executeMakeSymbolic(ExecutionState &state, 
                                   const MemoryObject *mo,
                                   const std::string &name) {
  llvm::outs() << "Inside Executor::executeMakeSymbolic()\n";
  // Create a new object state for the memory object (instead of a copy).
  if (!replayOut) {
    llvm::outs() << "Executor::executeMakeSymbolic(): replayOut is not NULL\n";
    // Find a unique name for this array.  First try the original name,
    // or if that fails try adding a unique identifier.
    unsigned id = 0;
    std::string uniqueName = name;
    while (!state.arrayNames.insert(uniqueName).second) {
      uniqueName = name + "_" + llvm::utostr(++id);
    }
    const Array *array = Array::CreateArray(uniqueName, mo->size);
    bindObjectInState(state, mo, false, array);
    state.addSymbolic(mo, array);
    
    std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
      seedMap.find(&state);
    if (it!=seedMap.end()) { // In seed mode we need to add this as a
                             // binding.
      llvm::outs() << "Executor::executeMakeSymbolic(): in seed mode.\n";
      for (std::vector<SeedInfo>::iterator siit = it->second.begin(), 
             siie = it->second.end(); siit != siie; ++siit) {
        SeedInfo &si = *siit;
        KTestObject *obj = si.getNextInput(mo, NamedSeedMatching);

        if (!obj) {
          if (ZeroSeedExtension) {
            std::vector<unsigned char> &values = si.assignment.bindings[array];
            values = std::vector<unsigned char>(mo->size, '\0');
          } else if (!AllowSeedExtension) {
            terminateStateOnError(state, 
                                  "ran out of inputs during seeding",
                                  "user.err");
            break;
          }
        } else {
          if (obj->numBytes != mo->size &&
              ((!(AllowSeedExtension || ZeroSeedExtension)
                && obj->numBytes < mo->size) ||
               (!AllowSeedTruncation && obj->numBytes > mo->size))) {
	    std::stringstream msg;
	    msg << "replace size mismatch: "
		<< mo->name << "[" << mo->size << "]"
		<< " vs " << obj->name << "[" << obj->numBytes << "]"
		<< " in test\n";

            terminateStateOnError(state,
                                  msg.str(),
                                  "user.err");
            break;
          } else {
            std::vector<unsigned char> &values = si.assignment.bindings[array];
            values.insert(values.begin(), obj->bytes, 
                          obj->bytes + std::min(obj->numBytes, mo->size));
            if (ZeroSeedExtension) {
              for (unsigned i=obj->numBytes; i<mo->size; ++i)
                values.push_back('\0');
            }
          }
        }
      }
    }
  } else {
    llvm::outs() << "Executor::executeMakeSymbolic(): replayOut is NULL\n";
    ObjectState *os = bindObjectInState(state, mo, false);
    if (replayPosition >= replayOut->numObjects) {
      terminateStateOnError(state, "replay count mismatch", "user.err");
    } else {
      KTestObject *obj = &replayOut->objects[replayPosition++];
      if (obj->numBytes != mo->size) {
        terminateStateOnError(state, "replay size mismatch", "user.err");
      } else {
        for (unsigned i=0; i<mo->size; i++)
          os->write8(i, obj->bytes[i]);
      }
    }
  }
}

/***/

void Executor::runFunctionAsMain(Function *f,
				 int argc,
				 char **argv,
				 char **envp) {
  std::vector<ref<Expr> > arguments;
  fprintf(stderr, "IVAN: Inside runFunctionAsMain\n");
  // force deterministic initialization of memory objects
  srand(1);
  srandom(1);
  
  MemoryObject *argvMO = 0;

  // In order to make uclibc happy and be closer to what the system is
  // doing we lay out the environments at the end of the argv array
  // (both are terminated by a null). There is also a final terminating
  // null that uclibc seems to expect, possibly the ELF header?

  int envc;
  for (envc=0; envp[envc]; ++envc) ;

  unsigned NumPtrBytes = Context::get().getPointerWidth() / 8;
  KFunction *kf = kmodule->functionMap[f];
  assert(kf);
  Function::arg_iterator ai = f->arg_begin(), ae = f->arg_end();
  if (ai!=ae) {
    arguments.push_back(ConstantExpr::alloc(argc, Expr::Int32)); // This creates a new constant experession

    if (++ai!=ae) {
      fprintf(stderr, "IVAN: allocating memory for the main function\n");
      argvMO = memory->allocate((argc+1+envc+1+1) * NumPtrBytes, false, true,
                                f->begin()->begin());
      
      arguments.push_back(argvMO->getBaseExpr());

      if (++ai!=ae) {
        uint64_t envp_start = argvMO->guest_address + (argc+1)*NumPtrBytes;
        arguments.push_back(Expr::createPointer(envp_start));

        if (++ai!=ae)
          klee_error("invalid main function (expect 0-3 arguments)");
      }
    }
  }

  ExecutionState *state = new ExecutionState(kmodule->functionMap[f]);
  
  if (pathWriter) 
    state->pathOS = pathWriter->open();
  if (symPathWriter) 
    state->symPathOS = symPathWriter->open();


  if (statsTracker)
    statsTracker->framePushed(*state, 0);

  assert(arguments.size() == f->arg_size() && "wrong number of arguments");
  for (unsigned i = 0, e = f->arg_size(); i != e; ++i)
    bindArgument(kf, i, *state, arguments[i]);

  if (argvMO) {
    ObjectState *argvOS = bindObjectInState(*state, argvMO, false);

    for (int i=0; i<argc+1+envc+1+1; i++) {
      if (i==argc || i>=argc+1+envc) {
        // Write NULL pointer
        argvOS->write(i * NumPtrBytes, Expr::createPointer(0));
      } else {
        char *s = i<argc ? argv[i] : envp[i-(argc+1)];
        int j, len = strlen(s);
        
        MemoryObject *arg = memory->allocate(len+1, false, true, state->pc->inst);
        ObjectState *os = bindObjectInState(*state, arg, false);
        for (j=0; j<len+1; j++)
          os->write8(j, s[j]);

        // Write pointer to newly allocated and initialised argv/envp c-string
        argvOS->write(i * NumPtrBytes, arg->getBaseExpr());
      }
    }
  }
  
  llvm::outs() << "Going inside initializeGlobals().\n";
  initializeGlobals(*state);
  llvm::outs() << "Returned from initializeGlobals().\n";

  processTree = new PTree(state);
  state->ptreeNode = processTree->root;

  /// IVAN ADDITIONS START
  //path_main_routine("printGesture", "printGesture");
  //path_main_routine("main", "main");
  //path_main_routine(StartFunction, TargetFunction);
  /// IVAN ADDITIONS END
  
  comp_symbex_target_reached = 0; // For forward symbex, the target is reached only when
                                  // we call assert()

  // Set good path summary chain
  llvm::outs() << "Executor::runFunctionAsMain(): executing run for function " << f->getName() << "\n";
  if(good_path_summaries.count(f))
  {
    //llvm::outs() << "We have a good path summary for this function. Let's check if we have conditions on" 
    //                " function parameters; we have " << good_path_summaries[f].size() << " summaries for this function\n";
    //state->guide_summaries.push_back(&(good_path_summaries[f][0]));
    llvm::outs() << "We have a good path summary for this function:\n";
    //state->cur_callgraph_fsummary = good_path_summaries[f][0];
    //state->next_callgraph_fsummary = find_next_callgraph_psummary(state->cur_callgraph_fsummary, f);
    //state->next_callgraph_fsummary = state->cur_callgraph_fsummary->next_path_summary;
    //state->cur_callgraph_fsummary->update_InnerCalls_with_constraints2(*(state->next_callgraph_fsummary));

    //state->cur_fsummary = state->cur_callgraph_fsummary;
    //state->cur_fsummary = good_path_summaries[f][2];
    state->cur_fsummary = start_summary;
    state->stack.back().cur_fsummary = state->cur_fsummary;
    //print_function_summary(good_path_summaries[f][2]);
    print_function_summary(start_summary);
    llvm::outs() << "enter integer\n";
    int tmp;
    //std::cin >> tmp;
  }
  else
  {
    llvm::outs() << "no good summaries for this function, exiting.\n";
    exit(0);
  }
  //forward_symbex = 1; // we already set in startCompositSymbex()
  
  //print_function_summary(state->cur_callgraph_fsummary);
  //print_function_summary(state->next_callgraph_fsummary);

  run(*state);
  delete processTree;
  processTree = 0;

  // hack to clear memory objects
  delete memory;
  memory = new MemoryManager();
  memory->arch = this->arch;
  
  globalObjects.clear();
  globalAddresses.clear();

  if (statsTracker)
    statsTracker->done();
}

void Executor::print_function_summary(path_summary_ty *smmry)
{
  if(!smmry)
  {
    llvm::outs() << "  NULL\n";
    return;
  }

  ref<Expr> fn_result = smmry->return_value;
  ConstraintManager fn_constraints = smmry->path_constraints;

  std::string Str;
  llvm::raw_string_ostream info(Str);
  ExprPPrinter::printConstraints(info, fn_constraints);
  llvm::outs() << "Res: " << fn_result  << "; constraints:\n" << info.str() << "\n";
  return;
}

void Executor::print_state_constraints(ExecutionState *state)
{
  //ref<Expr> fn_result = smmry->return_value;
  //ConstraintManager fn_constraints = smmry->path_constraints;

  std::string Str;
  llvm::raw_string_ostream info(Str);
  ExprPPrinter::printConstraints(info, state->constraints);
  llvm::outs() << "State: " << state  << "; constraints:\n" << info.str() << "\n";
  return;
}

void print_expressions(std::vector<ref<Expr> > vexpr)
{
  for(std::vector<ref<Expr> >::iterator it = vexpr.begin(); it != vexpr.end(); ++it)
    llvm::outs() << *it << "\n";
  return;
}


int Executor::print_summary_chains(path_summary_ty *path_smmry)
{
  llvm::outs() << "Executor::print_summary_chains(): inside\n";
  llvm::outs() << "Executor::print_summary_chains(): Considering path summary for function " << path_smmry->fn->getName() 
               << "() (it has " << path_smmry->call_symbolic_replacements.size() << " inner_calls)\n";
  print_function_summary(path_smmry);
  for(call_symbolic_replacements_ty::iterator it_1  = path_smmry->call_symbolic_replacements.begin();
                                              it_1 != path_smmry->call_symbolic_replacements.end(); ++it_1)
  {
    InnerCall *inner_call = it_1->second;
    llvm::Function *suppl_fn = inner_call->call_inst->getCalledFunction();
    llvm::outs() << "Executor::print_summary_chains(): Suppl call " << inner_call->seq_num 
                 << " for " << path_smmry->fn->getName() << "() (function " << suppl_fn->getName() << "()) has " 
                 << inner_call->connected_summaries.size() << " connected summaries (limit output to 2).\n";
    //if((f_s->getName().str() == "klee_div_zero_check") || (f_s->getName().str() == "abs_") || (f_s->getName().str() == "avg"))
    //{
    //  llvm::outs() << "Executor::explore_inner_call(): skipping klee_div_zero_check.\n";
    //  return 1;
    //}
    for(unsigned i = 0; (i<inner_call->connected_summaries.size()) && (i<=2); i++)
      print_summary_chains(inner_call->connected_summaries[i]);
    llvm::outs() << "Executor::print_summary_chains(): finished with Suppl call " << inner_call->seq_num 
                 << " for " << path_smmry->fn->getName() << "() (function " << suppl_fn->getName() << "())\n";
  }
  return 0;
}

///* We return 0 if for at least one suppl call, there are zero connected
// * summaries*/
//int Executor::paint_summary_chains(path_summary_ty *path_smmry)
//{
//  llvm::outs() << "Executor::print_summary_chains(): Considering path summary for function " << path_smmry->fn->getName() << "()\n";
//  print_function_summary(path_smmry);
//  int res = 1; // assume that summary is feasible
//  for(call_symbolic_replacements_ty::iterator it_1  = path_smmry->call_symbolic_replacements.begin();
//                                              it_1 != path_smmry->call_symbolic_replacements.end(); ++it_1)
//  {
//    InnerCall *inner_call = it_1->second;
//    llvm::Function *suppl_fn = inner_call->call_inst->getCalledFunction();
//    llvm::outs() << "Executor::print_summary_chains(): Suppl call " << inner_call->seq_num 
//                 << " for " << path_smmry->fn->getName() << "() (function " << suppl_fn->getName() << "()) has " << inner_call->connected_summaries.size()
//                 << " connected summaries.\n";
//    for(unsigned i = 0; i<inner_call->connected_summaries.size(); i++)
//      print_summary_chains(inner_call->connected_summaries[i]);
//  }
//  return 0;
//}


void Executor::print_function_summaries(std::map<llvm::Function *, std::vector<path_summary_ty *> > ps)
{
  //llvm::outs() << "Executor::runFunctionAsNonMain(): run() is finished, printing the collected summaries.\n";
  for (std::map<llvm::Function *, std::vector<path_summary_ty *> >::iterator it  = ps.begin();
                                                                           it != ps.end(); 
                                                                           ++it)
  {
    llvm::outs() << it->first->getName() << "\n"; // Function name
    std::vector<path_summary_ty *> fn_smmries = it->second; // vector of pairs of <function result, path constraints>.
    for (std::vector<path_summary_ty *>::iterator smmry  = fn_smmries.begin();
                                                smmry != fn_smmries.end(); ++smmry)
    {
      ref<Expr> fn_result = (*smmry)->return_value;
      ConstraintManager fn_constraints = (*smmry)->path_constraints;
      llvm::outs() << "Executor::print_function_summaries(): fn_constraints.size() = " << fn_constraints.size() << "\n";

      // KQUERY format printing 
      std::string Str;
      llvm::raw_string_ostream info(Str);
      ExprPPrinter::printConstraints(info, fn_constraints);
      llvm::outs() << "Res: " << fn_result  << "; constraints:\n" << info.str() << "\n";

      //// STP format
      //Query query(fn_constraints, ConstantExpr::alloc(0, Expr::Bool));
      //char *log = solver->getConstraintLog(query);
      //std::string res = std::string(log);
      //llvm::outs() << "Res: " << fn_result  << "; constraints:\n" << res << "\n";
      //free(log);
    }
  }
  return;
}

void Executor::make_interrupt_values_symbolic(ExecutionState *s)
{
  for(std::map<const llvm::GlobalValue*, MemoryObject*>::iterator it = globalObjects.begin();
                            it != globalObjects.end(); ++it)
  {
    const llvm::GlobalValue* gv = it->first;
    if(gv->getName().str() != "interrupt_values")
      continue;
    MemoryObject* mo = it->second;
    executeMakeSymbolic(*s, mo, "interrupt_values");
    llvm::outs() << "interrupt_values are symbolic now\n";
  }
  return;
}

void Executor::make_globals_symbolic(ExecutionState *s, std::vector<llvm::Value *> globals)
{
  for(std::vector<llvm::Value *>::iterator gv = globals.begin(); gv != globals.end(); ++gv)
  {
    llvm::outs() << "Executor::make_globals_symbolic(): making '" << (*gv)->getName() << "' symbolic\n";

    MemoryObject* mo = globalObjects[(GlobalValue *)(*gv)];



          unsigned id = 0;
          std::string name = (*gv)->getName().str();
          std::string uniqueName = name;
          while (!s->arrayNames.insert(uniqueName).second) {
            uniqueName = name + "_" + llvm::utostr(++id);
          }
          const Array *new_array = Array::CreateArray(uniqueName, mo->size);
          bindObjectInState(*s, mo, false, new_array);
          s->global_symbolic_replacements[*gv].push_back(new_array);



    //llvm::outs() << "       @" << mo->address << "\n";
    //executeMakeSymbolic(*s, mo, (*gv)->getName().str()); // This one just put new pair (mo, array) to s->symbolics
    //s->global_symbolic_replacements[*gv].push_back(s->symbolics[s->symbolics.size()-1].second);
  }
  llvm::outs() << "Executor::make_globals_symbolic(): state has the following symbolics now:\n";
  //for(std::vector<std::pair<const MemoryObject *, const Array *> >::iterator it = s->symbolics.begin();
  //                        it != s->symbolics.end(); ++it)
  //{
  //  llvm::outs() << "mo->name = " << it->first->name << "; array->name = " << it->second->getName() << 
  //               "@" << it->second << "\n"; 
  //}
  return;
}

std::vector<llvm::Value *> Executor::get_global_calling_context(Function *f)
{
  std::vector<llvm::Value *>  res;

  llvm::outs() << "DEBUG: the following global variables are used in " << f->getName() << "@" << f << ":\n";
  //llvm::outs() << "DEBUG: globalObjects.size() =  " << globalObjects.size()  << "\n";
  for(std::map<const llvm::GlobalValue*, MemoryObject*>::iterator it = globalObjects.begin(); it != globalObjects.end(); ++it)
  {
    llvm::GlobalValue* gv = (llvm::GlobalValue *)it->first;
    //llvm::outs() << "get_global_calling_context(): Considering " << gv->getName() << "\n";
    MemoryObject* mo = it->second;
    for(llvm::Value::use_iterator u_it=gv->use_begin(); u_it != gv->use_end(); ++u_it)
    {
      if(Instruction *Inst = dyn_cast<Instruction>(*u_it))
      {
        //llvm::outs() << "     -- in " << *Inst << " -- " << Inst->getParent()->getParent()->getName() << 
        //             "@" << Inst->getParent()->getParent() << "\n";
        if(Inst->getParent()->getParent() == f)
        {
          //llvm::outs() << "     " << Inst->getParent()->getParent()->getName() << "\n";
          llvm::outs() << "     " << gv->getName() << "\n";
          res.push_back(gv);
          break; // we are interested in just one usage
        }
      }
    } // for each usage
  } // for each globalValue
  return res;
}

//std::vector<llvm::Value *> Executor::get_global_calling_context(Function *f)
//{
//  std::vector<llvm::Value *>  res;
//  Module *m = kmodule->module;
//  llvm::outs() << "DEBUG: the following global variables are used in " << f->getName() << ":\n";
//  for(llvm::Module::global_iterator g_it=m->global_begin(); g_it != m->global_end(); ++g_it)
//    for(llvm::Value::use_iterator u_it=g_it->use_begin(); u_it != g_it->use_end(); ++u_it)
//      if (Instruction *Inst = dyn_cast<Instruction>(*u_it))
//        if(Inst->getParent()->getParent() == f)
//        {
//          //llvm::outs() << "     " << Inst->getParent()->getParent()->getName() << "\n";
//          llvm::outs() << "     " << g_it->getName() << "\n";
//          res.push_back(&(*g_it));
//          break; // we are interested in just one usage
//        }
//  return res;
//}

std::vector<std::pair<int, llvm::AllocaInst *> > extract_alloca_insts(Function *f)
{
  int inst_num = 0;
  std::vector<std::pair<int, llvm::AllocaInst *> > res;
  for(llvm::Function::iterator bb = f->begin(); bb != f->end(); ++bb)
    for(llvm::BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst)
    {
      AllocaInst *alloca_inst = dyn_cast<AllocaInst>(&*inst);
      if(alloca_inst)
      {
        llvm::outs() << "DEBUG: Found an alloca instruction: " << *alloca_inst << "\n";
        res.push_back(std::make_pair(inst_num, alloca_inst));
      }
      inst_num++;
    }
  return res;
}
      

std::vector<std::pair<int, llvm::StoreInst *> > extract_store_insts(Function *f)
{
  int inst_num = 0;
  std::vector<std::pair<int, llvm::StoreInst *> > res;
  for(llvm::Function::iterator bb = f->begin(); bb != f->end(); ++bb)
    for(llvm::BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst)
    {
      StoreInst *store_inst = dyn_cast<StoreInst>(&*inst);
      if(store_inst)
      {
        llvm::outs() << "DEBUG: Found a store instruction: " << *store_inst << "\n";
        llvm::Value *val0 = store_inst->getOperand(0);
        //llvm::Value *val2 = store_inst->getPointerOperand();
        llvm::Value *val1 = store_inst->getOperand(1);
        llvm::outs() << "    operand = : " << *val0 << "\n";
        llvm::outs() << "    operand = : " << *val1 << "\n";
        res.push_back(std::make_pair(inst_num, store_inst));
      }
      inst_num++;
    }
  return res;
}

std::vector<std::pair<int, llvm::LoadInst *> > extract_load_insts(Function *f)
{
  int inst_num = 0;
  std::vector<std::pair<int, llvm::LoadInst *> > res;
  for(llvm::Function::iterator bb = f->begin(); bb != f->end(); ++bb)
    for(llvm::BasicBlock::iterator inst = bb->begin(); inst != bb->end(); ++inst)
    {
      LoadInst *load_inst = dyn_cast<LoadInst>(&*inst);
      if(load_inst)
      {
        llvm::outs() << "DEBUG: Found a load instruction: " << *load_inst << "\n";
        res.push_back(std::make_pair(inst_num, load_inst));
        llvm::Value *val = load_inst->getPointerOperand();
        llvm::outs() << "    operand = : " << *val << "\n";
      }
      inst_num++;
    }
  return res;
}


//int get_inst_num(llvm::Instruction inst, std::vector<std::pair<int, llvm::Instruction *> > insts)
//{
//  return 0;
//}

/* Track dependecy of call arguments
 *
 * Look at the function call arguments and check if their values are
 * obtained from another function call.
 *
 * @param call_inst Call instruction to analyze
 */
void datadep_analyze_call_args(llvm::CallInst *call_inst)
{
  llvm::Function *f = call_inst->getParent()->getParent();
  std::vector<std::pair<int, llvm::LoadInst *> >  load_insts  = extract_load_insts(f);
  std::vector<std::pair<int, llvm::StoreInst *> > store_insts = extract_store_insts(f);
  std::vector<std::pair<int, llvm::AllocaInst *> > alloca_insts = extract_alloca_insts(f);

  CallSite cs(call_inst);
  unsigned numArgs = cs.arg_size();
  int numOperands = call_inst->getNumOperands();
  llvm::outs() << "The call to " << f->getName() << "() was made "
                "with " << numArgs  << " arguments. \n";

  int i = 0;
  for(llvm::CallSite::arg_iterator a_it = cs.arg_begin(); a_it != cs.arg_end(); ++a_it, i++)
  {
    llvm::Value *val = (*a_it);
    llvm::outs() << "arg: " << *val << "\n";
    LoadInst *load_inst = dyn_cast<LoadInst>(val);
    if(load_inst)
    {
      llvm::outs() << "it is a load instruction. Analyzing... \n";
      llvm::Value *val1 = load_inst->getPointerOperand();
      AllocaInst *alloca_inst = dyn_cast<AllocaInst>(val1);
      if(alloca_inst)
      {
        llvm::outs() << "The load instrution boils down to the following alloca inst: " << *alloca_inst << "\n";
        //int inst_num = get_inst_num(alloca_inst, alloca_insts);
        llvm::outs() << "Now Looking for \n";
      }

      //llvm::outs() << *val1 << "\n";
    }
    //for(llvm::Value::use_iterator u_it=val->use_begin(); u_it != val->use_end(); ++u_it)
    //  llvm::outs() << "     " << **u_it << "\n";
  }
}

/*  Get call instruction which correspond to symbolic values which
 *  replaced them in function <f>.
 *
 *  Correspondence between symbolic values and call instructions are
 *  contained in map <Executor::call_symbolic_replacements>.  We need
 *  only those call instructions whose symbolic values are in good_path_summaries
 *  for function <f>.
 *
 *  @param ps Path summary (i.e. function ret value, and path constraint) for function <f>
 *  @param f Function in which we had call instruction that were replaced by symbolics.
 *  @return vector with call instruction which we will need to execute
 *  
 */
//std::vector<llvm::CallInst *> Executor::resolve_call_symbolics(path_summary_ty ps, llvm::Function *f)
// The return value is a map. Key is a function which we need to call, and the value is the 
// constraints on the return value of the called function (i.e. it is
// the subset of the corresponding path condition).
// TODO: add constraints on global values.
//std::map<llvm::CallInst *, std::vector< ref<Expr> > > Executor::resolve_call_symbolics(llvm::Function *f, int ps_index_)
//std::map<llvm::CallInst *, std::vector< ref<Expr> > >
//      Executor::resolve_call_symbolics(llvm::Function *f, constraints_ty conds)
//{
//  llvm::outs() << "Executor::resolve_call_symbolic(): inside; for function " << f->getName() << "().\n";
//  std::map<llvm::CallInst *, std::vector< ref<Expr> > > calls;
//
//  call_symbolic_replacements_ty symb_replacements = call_symbolic_replacements[f];
//  //constraints_ty f_path_conditions = ps.second;
//
//  for(call_symbolic_replacements_ty::iterator it_1 = symb_replacements.begin(); it_1 != symb_replacements.end(); ++it_1)
//  {
//    ref<Expr> symb_replc = it_1->first; // Let's collect constraints for this symbolics
//    llvm::CallInst *call_inst = it_1->second; // Which replaced this call instruction
//
//    for(std::vector< ref<Expr> >::const_iterator it_2 = conds.begin(); it_2 != conds.end(); ++it_2)
//    {
//      const ref<Expr> e = *it_2;
//      std::vector<ref<Expr> > concats =  extract_concat_subexpressions(e);
//      for(std::vector<ref<Expr> >::iterator it_3 = concats.begin(); it_3 != concats.end(); ++it_3)
//      {
//        ref<Expr> concat = *it_3;
//        if(symb_replc == concat)
//        {
//          calls[call_inst].push_back(e);
//          break;
//        }
//      }
//    }
//  }
//  return calls;
//}

///* For each call instruction that was replaced by a symbolics, return the
// * the corresponding call instruction and conditions collected on those
// * symbolics along path summary <f1_smmry>*/
////std::map<llvm::CallInst *, std::vector< ref<Expr> > > 
//Executor::resolve_call_symbolics1(path_summary_ty &f1_smmry)
//{
//  llvm::Function *f1 = f1_smmry.fn; 
//  llvm::outs() << "Executor::resolve_call_symbolic1(): inside; for function " << f1->getName() << "().\n";
//  //std::map<llvm::CallInst *, std::vector< ref<Expr> > > calls;
//  call_symbolic_replacements_ty symb_replacements = f1_smmry.call_symbolic_replacements;
//
//  for(call_symbolic_replacements_ty::iterator it_1 = symb_replacements.begin(); 
//                                              it_1 != symb_replacements.end(); ++it_1)
//  {
//    ref<Expr> symb_replc = it_1->first; // symbolics
//    llvm::CallInst *call_inst = it_1->second; // which replaced this call instruction
//
//    /* First collect conditions along the f1's path summary. */
//    for(std::vector< ref<Expr> >::const_iterator it_2 = f1_smmry.path_constraints.begin();
//                                                 it_2 != f1_smmry.path_constraints.end(); ++it_2)
//    {
//      const ref<Expr> e = *it_2;
//      std::vector<ref<Expr> > concats =  extract_concat_subexpressions(e);
//      for(std::vector<ref<Expr> >::iterator it_3 = concats.begin(); it_3 != concats.end(); ++it_3)
//      {
//        ref<Expr> concat = *it_3;
//        if(symb_replc == concat)
//        {
//          calls[call_inst].push_back(e);
//          break;
//        }
//      }
//    }
//  }
//}
//    
////    std::vector<int> used_arg_indices;
////    /* Second check if the call symbolic replacement was used as f2's actual parameter */
////    std::vector<ref<Expr> > f2_actual_args = f1_smmry.target_func_actual_args;
////    for(unsigned i = 0; i < f2_actual_args.size(); i++)
////    {
////      if(symb_replc == f2_actual_args[i])
////      {
////        llvm::outs() << "call symbolics is a function arguments\n";
////        used_arg_indices.push_back(i);
////        exit(0);
////      }
////    }
////  }
////  return calls;
////}
//
//


bool Executor::check_formal_args_against_fsummary(path_summary_ty &smmry, std::vector<std::vector< ref<Expr> > > &formal_args_conditions)
{
  std::vector<ref<Expr> > combined_constraints;
  std::vector<ref<Expr> > debug_constraints; // keeps conditions on formal arguments (already replaced)
  unsigned numFormals = smmry.fargs.size();
  llvm::outs() << "Executor::check_formal_args_against_fsummary(): Creating combined (formal_args_conds + path_conds) contraints\n";
  for (unsigned i=0; i<numFormals; ++i) 
  {
    std::vector< ref<Expr> > arg_i_conditions = formal_args_conditions[i];
    for(std::vector< ref<Expr> >::iterator it = arg_i_conditions.begin(); it != arg_i_conditions.end(); ++it)
    {
      /*ref<Expr> cond = *it;
      comp_symbex_replace_for_retvalue(cond, smmry.fargs[i]);
      combined_constraints.push_back(cond);
      debug_constraints.push_back(cond);*/
      ref<Expr> cond = *it;
      ref<Expr> tmp = comp_symbex_replace_for_retvalue(cond, smmry.fargs[i]);
      combined_constraints.push_back(tmp);
      debug_constraints.push_back(tmp);
    }
  }
  combined_constraints.insert(combined_constraints.end(), smmry.path_constraints.begin(), smmry.path_constraints.end());

  llvm::outs() << "Executor::check_formal_args_against_fsummary(): checking the following combined conditions:\n";
  for(std::vector<ref<Expr> >::iterator it = combined_constraints.begin(); it != combined_constraints.end(); ++it)
    llvm::outs() << *it << "\n";
  
  if(combined_constraints.size() == 0)
  {
    llvm::outs() << "Executor::check_formal_args_against_fsummary(): Conditions are empty => result = 1 (true)\n";
    return true;
  }
  ConstraintManager cm(combined_constraints);
  bool solver_result;
  bool success = solver->solver->mayBeTrue(Query(cm, combined_constraints[0]), solver_result);

  // DEBUG STUFF BEGIN
  //ref<Expr> true_expr =  ConstantExpr::create(1, Expr::Bool);
  //ConstraintManager cm1(combined_constraints);
  //bool debug_result;
  Solver::Validity debug_result;
  bool success1;
  if((debug_constraints.size() != 0) && (smmry.path_constraints.size() != 0))
  {
    std::string res_str;
    //success1 = solver->solver->evaluate(Query(smmry.path_constraints, debug_constraints[0]), debug_result); 
    success1 = solver->solver->evaluate(Query(smmry.path_constraints, smmry.path_constraints.back()), debug_result); 
    if (debug_result == Solver::Unknown)
      res_str = "unknown";
    else if (debug_result == Solver::False)
      res_str = "0";
    else if (debug_result == Solver::True)
      res_str = "1";
    llvm::outs() << "Executor::check_formal_args_against_fsummary(): debug_result = " << res_str << "\n";
  }
  else
    llvm::outs() << "Executor::check_formal_args_against_fsummary(): no additional constraints on formals\n";
  // DEBUG STUFF END

  // DEBUG STUFF BEGIN
  //ref<Expr> true_expr =  ConstantExpr::create(1, Expr::Bool);
  //ConstraintManager cm1(combined_constraints);
  //bool debug_result;
  //bool success1 = solver->solver->mayBeTrue(Query(cm1, true_expr), debug_result);
  //llvm::outs() << "Executor::check_formal_args_against_fsummary(): debug_result = " << debug_result << "\n";
  // DEBUG STUFF END

  assert(success && "FIXME: Unhandled solver failure");
  llvm::outs() << "Executor::check_formal_args_against_fsummary(): result = " << solver_result << "\n";

  if(!solver_result)
    return false;

  return true;

}


/* Replace all concat expressions in <conditions> with <x> and check
 * the system can be solved.*
 */
bool Executor::conds_are_solvable(ref<Expr> x, std::vector< ref<Expr> > *conditions)
{
  if(conditions->size() == 0)
    return true;

  bool solver_result = true;
  /* Replace concat expressions in each condition with <x>. */
  std::vector<ref<Expr> > vexpr;
  for(std::vector< ref<Expr> >::iterator it_expr = conditions->begin();
                                         it_expr != conditions->end(); ++it_expr)
  {
    ref<Expr> e = *it_expr;
    BinaryExpr *be = dyn_cast<BinaryExpr>(e);

    /*
    // Create a temporary copy
    ref<Expr> arr[2];
    arr[0] = be->left;
    arr[1] = be->right;
    ref<Expr> tmp = e->rebuild(arr);
    //llvm::outs() << "Executor::conds_are_solvable(): replacing concats in\n" << tmp << "\n"
    //                "with " << x << "\n";
    //comp_symbex_replace_for_retvalue(tmp, x);


    //llvm::outs() << "Executor::conds_are_solvable(): the updated constraint:\n" << tmp << "\n";
    */ 

    ref<Expr> tmp = comp_symbex_replace_for_retvalue(e, x);

    vexpr.push_back(tmp);
  }

  llvm::outs() << "Executor::conds_are_solvable(): checking the following constraints:\n";
  print_expressions(vexpr);

  ref<Expr> true_expr =  ConstantExpr::create(1, Expr::Bool);
  ConstraintManager cm(vexpr);
  //bool success = solver->solver->mayBeTrue(Query(cm, true_expr), solver_result);
  //bool success = solver->solver->mayBeTrue(Query(cm, vexpr.back()), solver_result);
  for(std::vector< ref<Expr> >::iterator it = vexpr.begin(); it != vexpr.end(); ++it)
  {
    bool success = solver->solver->mayBeTrue(Query(cm, *it), solver_result);
    assert(success && "FIXME: Unhandled solver failure");
    if(!solver_result)
      break;
  }
  llvm::outs() << "Executor::conds_are_solvable(): result = " << solver_result << "\n";

  if(!solver_result)
    return false;

  return true;
}


/* f1 should call f2 along the call path */
bool Executor::comp_symbex_can_glue1(path_summary_ty &f1_smmry, path_summary_ty &f2_smmry)
{
  if(f1_smmry.target_func_actual_args.size() == 0)
    return true;

  bool can_glue = false;
  std::vector<std::vector<ref<Expr> > > f2_actual_arg_conds; // We keep conditions (for f2's actual arguments) from f1's state.constraints
  std::vector<std::vector<ref<Expr> > > f2_formal_arg_conds;  // Stores conditions on f2_formal_arg, which are extracted from a summary
  std::vector<ref<Expr> > aggregated_conds;

  //std::vector<ref<Expr> > f2_formal_args = fargs[f2_smmry.fn];
  std::vector<ref<Expr> > f2_formal_args = f2_smmry.fargs;

  llvm::outs() << "Executor::comp_symbex_can_glue1(): f1_name = " << f1_smmry.fn->getName() << "(); f2_name =  " <<
                  f2_smmry.fn->getName() << "()\n";

  llvm::outs() << "Executor::comp_symbex_can_glue1(): f2_formal_args.size() = " << f2_formal_args.size() <<
                   "; f1_smmry.target_func_actual_args.size() = " << f1_smmry.target_func_actual_args.size() << "\n";
  assert((f2_formal_args.size() == f1_smmry.target_func_actual_args.size()) && "Number of formal and actual arguments is different");
  unsigned num_args = f2_formal_args.size(); 

  /* Init arrays */
  for(unsigned i=0; i < num_args; i++)
    {std::vector<ref<Expr> > v1; f2_actual_arg_conds.push_back(v1);
     std::vector<ref<Expr> > v2; f2_formal_arg_conds.push_back(v2);}

  /*  Collect constraints for each actual argument from f1_smmry */
  llvm::outs() << "Executor::comp_symbex_can_glue1(): Extracting constraints for actual arguments from f1_smmry.path_constraints.\n";
  for(std::vector< ref<Expr> >::const_iterator it_1  = f1_smmry.path_constraints.begin(); 
                                               it_1 != f1_smmry.path_constraints.end(); ++it_1) //For each condition in the summary
  {
    const ref<Expr> cond = *it_1;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(cond);
    for(unsigned i=0; i<num_args; i++)
    {
      assert(isa<ConcatExpr>(f1_smmry.target_func_actual_args[i]) && "f1_smmry.target_func_actual_args[i] is not a ConcatExpr");
      for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
      { 
        ref<Expr> concat = *it_2;
        if(f1_smmry.target_func_actual_args[i] == concat) 
        {
          f2_actual_arg_conds[i].push_back(cond);
          break;
        }
      }
    }
  }

  /*  Collect constraints for each formal argument from f2_smmry. */
  llvm::outs() << "Executor::comp_symbex_can_glue1(): Extracting constraints for formal arguments from f2_smmry.path_constraints.\n";
  for(std::vector< ref<Expr> >::const_iterator it_1  = f2_smmry.path_constraints.begin(); 
                                               it_1 != f2_smmry.path_constraints.end(); ++it_1) //For each condition in the summary
  {
    const ref<Expr> cond = *it_1;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(cond);
    for(unsigned i=0; i<num_args; i++)
    {
      assert(isa<ConcatExpr>(f2_formal_args[i]) && "f2_formal_args[i] is not a ConcatExpr");
      for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
      { 
        ref<Expr> concat = *it_2;
        if(f2_formal_args[i] == concat) 
        {
          f2_formal_arg_conds[i].push_back(cond);
          break;
        }
      }
    }
  }

  bool solver_result = false;
  aggregated_conds.clear();

  /* For each pair of actual and formal arguments */
  for(unsigned i=0; i<num_args; i++)
  {
    /* Combine constraints for acutal and formal arguments, and check if
     * they contradict */
    aggregated_conds.clear();
    aggregated_conds.insert(aggregated_conds.end(), f2_actual_arg_conds[i].begin(), f2_actual_arg_conds[i].end());
    aggregated_conds.insert(aggregated_conds.end(), f2_formal_arg_conds[i].begin(), f2_formal_arg_conds[i].end());
    llvm::outs() << "Executor::comp_symbex_can_glue1(): We collected constraints both for formal and"
                        " actual parameters for arg " << i 
                        << ". Checking if they are compatible (aggregated_conds.size() = " 
                        << aggregated_conds.size() << "):\n";
    for(std::vector<ref<Expr> >::iterator it_2 = aggregated_conds.begin(); it_2 != aggregated_conds.end(); ++it_2)
      llvm::outs() << *it_2 << "\n";
    if(aggregated_conds.size() == 0)
      solver_result = true;
    else
      solver_result = conds_are_solvable(f2_formal_args[i], &aggregated_conds);
    llvm::outs() << "Executor::comp_symbex_can_glue1(): solver's results = " << solver_result << "\n";

    if(!solver_result)
      break;
  }

  if(solver_result)
  {
    llvm::outs() << "Executor::comp_symbex_can_glue1(): can glue with this summary\n";
    can_glue = true;
  }
  else
  {
    llvm::outs() << "Executor::comp_symbex_can_glue1(): cannot glue with this summary\n";
    can_glue = false;
  }
  return can_glue;

}



/* f1 is being symbolically executed (backwards pass);
 * it calls f2 and wants to know if they can glue
 * together given the current f1's state conditions.
 *
 * The main idea is the following: previously when we were executing
 * function f2 we made its formal arguments symbolic and saved them
 * for the future reference in map <fargs>. f2's good_summaries set
 * conditions on the formal arguments.
 *
 * On the other hand, f1's state <f1_state> just reached a call to f2. This state
 * has constraints on the actual arguments of the call <f2_actual_args>.
 * So we combine both constraints and check if they do not contradict.
 * We do this for each f2's summary. If for at least one summary there
 * is no contradiction, we decide that we can glue two functions.
 *
 * @param f1             Function for which we were doing backward symbex, and which 
 *                       called <f2>
 * @param f1_state       Exectuion state of function f1 at the moment when it
 *                       called f2
 * @param f2_actual_args These are arguments (expressions) with which <f1> called <f2>
 */
bool Executor::comp_symbex_can_glue(llvm::Function *f1, ExecutionState &f1_state, std::vector< ref<Expr> > f2_actual_args)
{
  llvm::Function *f2 = f1_state.target_func;
  llvm::outs() << "Executor::comp_symbex_can_glue(): Checking if function " << 
                   f1->getName() << "() with " << f2_actual_args.size() << " arguments can be glued with " << 
                   "on-path function " << f2->getName() << "()\n";
  if(f2_actual_args.size() == 0)
    return true;

  bool can_glue = false;
  std::vector<std::vector<ref<Expr> > > f2_actual_arg_conds; // We keep conditions (for f2's actual arguments) from f1's state.constraints
  std::vector<std::vector<ref<Expr> > > f2_formal_arg_conds;  // Stores conditions on f2_formal_arg, which are extracted from a summary
  std::vector<ref<Expr> > aggregated_conds;
  //std::vector<ref<Expr> > f2_formal_args = fargs[f2];
  //std::vector<ref<Expr> > f2_formal_args = f2_smmry.fargs;
  
  /* Initialize: f2_actual_args and f2_formal_arg_conds are vectors of vectors. We
   * need to initialize the first vecotor (which is contains vectors) */
  for(unsigned i=0; i<f2_actual_args.size(); i++)
  {
    std::vector<ref<Expr> > v1;
    f2_actual_arg_conds.push_back(v1);
    std::vector<ref<Expr> > v2;
    f2_formal_arg_conds.push_back(v2);
  }

  /*  Collect constraints for each actual argument from the current state. */
  llvm::outs() << "Extracting constraints for actual arguments from f1_state.constraints.\n";
  for(std::vector< ref<Expr> >::const_iterator it_1  = f1_state.constraints.begin(); 
                                               it_1 != f1_state.constraints.end(); ++it_1) //For each condition in the summary
  {
    const ref<Expr> cond = *it_1;
    std::vector<ref<Expr> > concats = extract_concat_subexpressions(cond);
    for(unsigned i=0; i<f2_actual_args.size(); i++)
    {
      assert(isa<ConcatExpr>(f2_actual_args[i]) && "f2_actual_arg is not a ConcatExpr");
      for(std::vector<ref<Expr> >::iterator it_2 = concats.begin(); it_2 != concats.end(); ++it_2) 
      { 
        ref<Expr> concat = *it_2;

        if(f2_actual_args[i] == concat) 
        {
          f2_actual_arg_conds[i].push_back(cond);
          break;
        }
      }
    }
  }


  std::vector<path_summary_ty *> f2_summaries = good_path_summaries[f2];
  for(std::vector<path_summary_ty *>::iterator it_1 = f2_summaries.begin(); it_1 != f2_summaries.end(); ++it_1) // For each f2's summary
  {
    llvm::outs() << "Executor::comp_symbex_can_glue(): considering the following function summary:\n";
    print_function_summary(*it_1); // Function summaries which go along the call path
    constraints_ty &f2_summary_conds = (*it_1)->path_constraints;
    std::vector<ref<Expr> > f2_formal_args = (*it_1)->fargs;
    //f2_formal_arg_conds.clear();
    for(unsigned i=0; i<f2_actual_args.size(); i++)
      f2_formal_arg_conds[i].clear();

    /*  Collect constraints for each formal argument. */
    llvm::outs() << "Extracting constraints for formal arguments from the summary.\n";
    for(std::vector< ref<Expr> >::const_iterator it_2 = f2_summary_conds.begin(); it_2 != f2_summary_conds.end(); ++it_2) //For each condition in the summary
    {
      const ref<Expr> cond = *it_2;
      std::vector<ref<Expr> > concats = extract_concat_subexpressions(cond);
      for(unsigned i=0; i<f2_formal_args.size(); i++)
      {
        assert(isa<ConcatExpr>(f2_formal_args[i]) && "f2_formal_arg is not a ConcatExpr");
        for(std::vector<ref<Expr> >::iterator it_3 = concats.begin(); it_3 != concats.end(); ++it_3) 
        { 
          ref<Expr> concat = *it_3;
          if(f2_formal_args[i] == concat) 
          {
            f2_formal_arg_conds[i].push_back(cond);
            break;
          }
        } 
      }
    }

    bool solver_result = false;
    aggregated_conds.clear();

    /* For each pair of actual and formal arguments */
    for(unsigned i=0; i<f2_actual_args.size(); i++)
    {
      /* Combine constraints for acutal and formal arguments, and check if
       * they contradict */
      aggregated_conds.clear();
      aggregated_conds.insert(aggregated_conds.end(), f2_actual_arg_conds[i].begin(), f2_actual_arg_conds[i].end());
      aggregated_conds.insert(aggregated_conds.end(), f2_formal_arg_conds[i].begin(), f2_formal_arg_conds[i].end());
      llvm::outs() << "Executor::comp_symbex_can_glue(): We collected constraints both for formal and"
                          " actual parameters for arg " << i 
                          << ". Checking if they are compatible (aggregated_conds.size() = " 
                          << aggregated_conds.size() << "):\n";
      for(std::vector<ref<Expr> >::iterator it_2 = aggregated_conds.begin(); it_2 != aggregated_conds.end(); ++it_2)
        llvm::outs() << *it_2 << "\n";

      if(aggregated_conds.size() == 0)
        solver_result = true;
      else
        solver_result = conds_are_solvable(f2_formal_args[i], &aggregated_conds);
      llvm::outs() << "Executor::comp_symbex_can_glue(): solver's results = " << solver_result << "\n";

      if(!solver_result)
        break;

    } 

    if(solver_result)
    {
      llvm::outs() << "Executor::comp_symbex_can_glue(): can glue with this summary\n";
      can_glue = true;
    }
    else
    {
      llvm::outs() << "Executor::comp_symbex_can_glue(): cannot glue with this summary\n";
    }
  }
  return can_glue;
}



int Executor::explore_inner_call(InnerCall *inner_call)
{
  /**** 1. Hack to skip path summary for klee_div_zero_check() ****/
  llvm::CallInst *ci = inner_call->call_inst;
  llvm::Function *f_s = ci->getCalledFunction();
  if((f_s->getName().str() == "klee_div_zero_check") || (f_s->getName().str() == "abs_") || (f_s->getName().str() == "avg")
       || (f_s->getName().str() == "memset"))
  {
    //llvm::outs() << "Executor::explore_inner_call(): skipping klee_div_zero_check.\n";
    return 1;
  }
  
  /**** 2. Some debug printing ****/
  llvm::outs() << "Executor::explore_inner_call(): The following call instruction"
                   " was replaced with a symbolic: " << *ci << "\n";
  llvm::outs() << "Executor::explore_inner_call(): Suppl call has the following pre-constraints on formal args:\n";
  /* a. print conditions on formal args (e.g. if we called classifyGesture(3)) ****/
  if(inner_call->formal_args_conditions.size() > 0)
    for(unsigned i = 0; i<inner_call->formal_args_conditions.size(); i++)
    {
      llvm::outs() << "For arg" << i << "\n";
      print_expressions(inner_call->formal_args_conditions[i]);
    }
    else
      llvm::outs() << "  empty\n";
  
  llvm::outs() << "Executor::explore_inner_call(): First let's check if we "
                   " already have a fitting path summary for the called function\n";
  
  /**** 2. Combine inner_call's retval_conditions and retval_conditions2 (if they exist) into one array <retvalue_conds> ****/
  //std::vector<ref<Expr> > retvalue_conds = inner_call->retval_conditions;
  //retvalue_conds.insert(retvalue_conds.end(), inner_call->retval_conditions2.begin(), inner_call->retval_conditions2.end());
  //llvm::outs() << "Executor::explore_inner_call(): We have the following "
  //                "condtions on the ruturn value (retval_conditions+revalconditions2):\n";
  //for(std::vector<ref<Expr> >::iterator it_1 = retvalue_conds.begin(); it_1 != retvalue_conds.end(); ++it_1)
  //  llvm::outs() << *it_1 << "\n";
  
  /**** 3. Go through all existing path summaries for <f_s>, and find
  *       those whose 1) return value and 2) formal arg constraints satisfy
  *       inner_call. Add pointers to such summaries to inner_call.connected_summaries ****/
  states.clear();
  // FIXME: we have a potential memory leak here 
  
  /* path_summaries[f_s].clear(); */
  
  //llvm::outs() << "Executor::explore_inner_call(): running runInnerCall() " << inner_call << " (function " << f_s->getName() << 
  //                ") connectes_summaries = " << inner_call->connected_summaries.size() << " .\n";
  
   
  if(should_collect_more_summaries[f_s])
  {
    llvm::outs() << "Executor::explore_inner_call(): going to collect more summaries for function " << f_s->getName() <<
                    "() which has " << path_summaries[f_s].size() << " summaries so far\n";
    runInnerCall(*inner_call);   // This is almost a copy of runFunctionAsNonMain(); This will collect <path_summaries> and <good_path_summaries> for f_s.
  }



  //if(!it_1->second.path_summary_found)
  //if(!inner_call->path_summary_found)
  //{
  //  llvm::outs() << "Executor::explore_inner_call(): Could not find a good path summary for "
  //                  "suppl call " << *(inner_call->call_inst) << ". This means that the current"
  //                  " path summary for function " << inner_call->call_inst->getParent()->getParent()->getName()
  //                  << "() is infeasible (returning 0).\n";
  //  return 0;
  //}
  //llvm::outs() << "Executor::explore_inner_call(): runInnerCall() is finished. Now executing inner_calls"
  //  " for each collected summary for function " << f_s->getName() << ".\n";
  llvm::outs() << "Executor::explore_inner_call(): runInnerCall() is finished for function " << f_s->getName() << 
                  "(); we collected " << path_summaries[f_s].size() 
                  << " summaries; connsumms = " << inner_call->connected_summaries.size() << " .\n";

  /* If we are here then at least one summary for inner_call satisfied all constraints:
   * retvalue + formal_args_constraints (we will check it once again
   * below);
   * Now we need to check if we can find appropriate inner_calls */
  int at_least_one_summary_has_all_InnerCalls = 0;
  for(std::vector<path_summary_ty *>::iterator it_1 = path_summaries[f_s].begin(); it_1 != path_summaries[f_s].end(); ++it_1)
  {
    llvm::outs() << "Executor::explore_inner_call(): -- Checking (and adapting its suppl calls) next "
                    " function summary for function "<< f_s->getName() << "()\n";
    path_summary_ty *original_path_summary = *it_1;
    path_summary_ty *copy_path_summary = new PathSummary(original_path_summary);
    adapt_psummary_to_inner_call(inner_call, copy_path_summary);
    ref<Expr> summary_retvalue = copy_path_summary->return_value;
    llvm::outs() << "Executor::explore_inner_call(): Checking the following function summary (for function "
                 << f_s->getName() << ") and return value: "  << summary_retvalue << "; constraints:\n";
      print_function_summary(copy_path_summary);
    llvm::outs() << "Executor::explore_inner_call(): and this is original summary:\n";
      print_function_summary(original_path_summary);

    std::vector<ref<Expr> > retvalue_conds = inner_call->retval_conditions;
    retvalue_conds.insert(retvalue_conds.end(), inner_call->retval_conditions2.begin(), inner_call->retval_conditions2.end());
    //copy_path_summary->update_InnerCalls_with_constraints();
    /* If the return value is one of the formal arguments, then we need
       to add constraints on that formal arg to retvalue_conds (for example:
       int func(int a) {return a} which was invoked func(3) and should return 2*/
    for(unsigned i = 0; i<copy_path_summary->fargs.size(); i++)
    {
      if(summary_retvalue == copy_path_summary->fargs[i])
      {
        llvm::outs() << "Executor::explore_inner_call(): Adding the following constraints to retvalue conds (due to formal args):\n";
        print_expressions(inner_call->formal_args_conditions[i]);
        retvalue_conds.insert(retvalue_conds.end(), inner_call->formal_args_conditions[i].begin(), inner_call->formal_args_conditions[i].end());
      }
    }
    llvm::outs() << "Executor::explore_inner_call(): here are the suppl call constraints on retvalue:\n";
    print_expressions(retvalue_conds);

    if(conds_are_solvable(summary_retvalue, &retvalue_conds)) // this will replace all concats with result, and check if result satisfies state.ret_value_constraints
    {
      llvm::outs() << "Executor::explore_inner_call(): return value is good:" << summary_retvalue << "\n";
      if(check_formal_args_against_fsummary(*copy_path_summary, inner_call->formal_args_conditions)) /* check formal args conds */
      {
        llvm::outs() << "Executor::explore_inner_call(): formal args pre-constraints are good. checking inner_calls\n";
        int res = 1;
        for(call_symbolic_replacements_ty::iterator it_2  = copy_path_summary->call_symbolic_replacements.begin(); /* check all symbolic replacements */
                                                    it_2 != copy_path_summary->call_symbolic_replacements.end(); ++it_2)
  
        {
          res = explore_inner_call(it_2->second);
          if(res == 0)
            break; // if at least on suppl call is infeasilbe, then this summary is infeasible
        }
        if(res)
        {
          //llvm::outs() << "Executor::explore_inner_call(): all sup calls are good. Adding this path summary to the inner_call\n";
          llvm::outs() << "Executor::explore_inner_call(): inner_call " << inner_call->seq_num << " (" << inner_call << ")"
                    " for " << inner_call->call_inst->getParent()->getParent()->getName() << "() (function " <<
                    f_s->getName() << "()): all sub sup calls are good for summary (adding):\n"; 
          print_function_summary(copy_path_summary);
          inner_call->connected_summaries.push_back(copy_path_summary);
          at_least_one_summary_has_all_InnerCalls = 1;
        }
         else
          llvm::outs() << "sup calls are not good.\n";
      }
      else
        llvm::outs() << "formal args pre-constraints are NOT good\n";
    }
    else
      llvm::outs() << "return value is NOT good:" << summary_retvalue << "\n";
  }
  if(at_least_one_summary_has_all_InnerCalls)
    llvm::outs() << "Executor::explore_inner_call(): at least one summary for inner_call " << inner_call->seq_num <<
                    " for " << inner_call->call_inst->getParent()->getParent()->getName() << "() (function " <<
                    f_s->getName() << "()) has all suppcalls\n"; 
  else
    llvm::outs() << "Executor::explore_inner_call(): no summary for inner_call " << inner_call->seq_num <<
                    " for " << inner_call->call_inst->getParent()->getParent()->getName() << "() (function " <<
                    f_s->getName() << "()) has all suppcalls\n"; 
  llvm::outs() << "Executor::explore_inner_call(): inner_call " << inner_call->seq_num << "(" << inner_call << ")"
                    " for " << inner_call->call_inst->getParent()->getParent()->getName() << "() (function " <<
                    f_s->getName() << "()) has " << inner_call->connected_summaries.size() << " connected summaries\n"; 
  llvm::outs() << "Executor::explore_inner_call(): returning " << at_least_one_summary_has_all_InnerCalls << "\n";
  return at_least_one_summary_has_all_InnerCalls;
}

int Executor::run_supplementary_functions(path_summary_ty &path_smmry)
{
  /* Go through all call symbolic replacements */
  for(call_symbolic_replacements_ty::iterator it_1  = path_smmry.call_symbolic_replacements.begin();
                                              it_1 != path_smmry.call_symbolic_replacements.end(); ++it_1)
  {
    InnerCall *inner_call = it_1->second;
    llvm::outs() << "Executor::run_supplementary_functions(): exploring inner_call " << inner_call << "\n";
    int res = explore_inner_call(inner_call);
    if(res == 0)
      return 0;
  }
  return 1;
}



void Executor::merge_dublicated_good_summaries(llvm::Function *f)
{
  std::vector<path_summary_ty *> good_summaries = good_path_summaries[f];
  std::vector<path_summary_ty *> unique;
  unsigned i,j;
  bool should_add;

  for(i=0;i<good_summaries.size();i++)
  {
    path_summary_ty *s1 = good_summaries[i];

    should_add = true;
    for(j=0;j<unique.size();j++)
    {
      path_summary_ty *s2 = unique[j];
      if(s1->has_the_same_path_instructions(s2))
      {
        should_add = false;
        break;
      }
    }

    if(should_add)
      unique.push_back(s1);
  }

  good_path_summaries[f] = unique;
  return;
}

/* This function start compositional symbolic execution
 *
 * This function first launches backward compositional symbolic
 * execution along the previously build path from main() to assert(). It
 * determines and stores constraints on the formal and actual arguments
 * of the function along the path, and constraints on return values for
 * function which are invoked in between.
 *
 * Second, this function launches forward symbolic execution, trying not
 * to deviate the path, and reusing the collected during the previous
 * step function summaries.
 * 
 * Parameters to this function are used only for forward symbolic execution.
 * 
 * @param f Pointer to the main function (i.e. the  function from which we want to start forward symbex)
 * @param argc
 * @param argv
 * @param envp Parameters for the main function.
*/
void Executor::startCompositSymbEx(Function *mainFn,
				 int pArgc,
				 char **pArgv,
				 char **pEnvp)
{

                                             /*** Backward symbex ***/
  
  /// DEBUG BEGIN
  PathManager *path_manager = new PathManager(start_function_name, target_function_name, this->kmodule);
  /// DEBUG END

  initializeMergeBlackList();
  min_num_of_summaries_to_collect = 15;
  prefer_short_summaries = false;
  forward_symbex = 0;
  //module_constansts_bound = false;
  Function *f1;
  Function *f2;
  //bindModuleConstants();

  for(unsigned i = 1; i<= call_path.size()-1; i++)
  {
    f1 = (Function *)call_path[call_path.size()-(i+1)]; // the one which calls assert() = printGesture()
    f2 = (Function *)call_path[call_path.size()-i]; // assert() 
    llvm::outs() << " +++ Executor::startCompositSymbEx(): running symbex for path part: " << f1->getName() 
                 << "() -> " << f2->getName() << "().\n";
    // start execution from f1 and until a call to f2 is reached.
    // This will replace all other calls with symbolics and put them to <call_symbolic_replacements>
   
    
    rand_search_freq = 1;
    path_summaries[f1].clear();
    runFunctionAsNonMain(f1, f2,  NULL); // This will collect path summaries for f1 and store it in the <path_summaries> and <good_path_summaries>

    //int tmp;
    //std::cin >> tmp;

    rand_search_freq = 20;
    path_summaries[f1].clear();
    runFunctionAsNonMain(f1, f2,  NULL);
    merge_dublicated_good_summaries(f1); // remove dublicated summaries from good_path_summaries
    llvm::outs() << " +++ Executor::startCompositSymbEx(): on-path function run() is finished for '" << f1->getName() << "()', printing the collected summaries.\n";
    llvm::outs() << "good_path_summaries[f1].size() = " << good_path_summaries[f1].size() << "\n";
    print_function_summaries(good_path_summaries); // Function summaries which go along the call path
    llvm::outs() << "DEBUG: Number of states which we need to delete = " << states.size() << "\n";
    llvm::outs() << "DEBUG: I will now collect call instructions which were replaced by symbolics...\n";
    //exit(0);

    int tmp;
    //std::cin >> tmp;

    /* Run supplementary functions (those which we replaced by symbolics) */

    /* In case of the function which calls assert(), we do not need to
     * glue it with other summaries */
    if (f2 == (Function *)call_path[call_path.size()-1]) // If the next function is assert()
    {
      std::vector<path_summary_ty *> smmries = good_path_summaries[f1];
      llvm::outs() << "Executor::startCompositSymbEx(): looking for the last before assert() function: " << f1->getName() <<
                       "() ( " << smmries.size() << " summaries)\n";
      for(std::vector<path_summary_ty *>::iterator it_1 = smmries.begin(); it_1 != smmries.end(); ++it_1)
      {
        llvm::outs() << "Executor::startCompositSymbEx(): considering summary:\n";
        print_function_summary(*it_1);
        (*it_1)->update_InnerCalls_with_constraints();
        int res = run_supplementary_functions(**it_1);
        if(res != 0)
        {
          llvm::outs() << "Executor::startCompositSymbEx(): the following summary chain for " 
                         << (*it_1)->fn->getName() << "() is gluable and has appropriate suppl calls\n";
          //std::string str((*it_1)->path_choices.begin(), (*it_1)->path_choices.end());
          //llvm::outs() << "Executor::startCompositSymbEx(): here is its path choices:\n";
          //for(std::vector<int>::iterator it_2 = (*it_1)->path_choices.begin(); it_2 != (*it_1)->path_choices.end(); ++it_2)
          //  llvm::outs() << *it_2 << " -> ";
          //llvm::outs() << "\n\n";

          //for(std::vector<llvm::Instruction *>::iterator it_2 = (*it_1)->path_instructions.begin(); it_2 != (*it_1)->path_instructions.end(); ++it_2)
          //  llvm::outs() << **it_2 << "\n";
          //exit(0);
          //print_summary_chains(*it_1);
        }
      }
    } 
    /* We need to find summaries of the next function with which we can
     * glue and update constraints on call symbolics */
    else
    {
      /* We do the following.
       * 1. We consider each good (so far) f1's summary.
       * 2. If we can glue it with an f2's summary, we make a copy of
       *    this summary (this copy will have no connected summaries for
       *    its suppl calls).
       * 3. Try to collect all suppl calls for the copy.
       * 4. If all suppl calls can be collected, save the copy 
       * 5. Erase all old good summaries for f1 (if a summary was really
       *    good, we have its copies in in the copy list
       * 6. Move summaries from the copy list to good_summaries[f1] list */
      std::vector<path_summary_ty *> &f1_smmries = good_path_summaries[f1];
      std::vector<path_summary_ty *> &f2_smmries = good_path_summaries[f2];
      std::vector<path_summary_ty *> summaries_to_keep; // if we can glue (+find all supp calls) f1 summary with a f2's summary, we add a copy here
      llvm::outs() << "Executor::startCompositSymbEx(): looking for summaries which we can glue for functions: " << f1->getName() <<
                       "() ( " << f1_smmries.size() << " summaries) and " << f2->getName() << "() ("
                       <<  f2_smmries.size() << " summaries)\n";
      int i = 0, j = 0;
      bool time_to_start_forwrad_symbex_debug = false;
      for(std::vector<path_summary_ty *>::iterator it_1 = f1_smmries.begin(); it_1 != f1_smmries.end(); ++it_1)
      {
        if(time_to_start_forwrad_symbex_debug)
          break;
        i++;
        j = 0;
        path_summary_ty *f1_smmry = *it_1;
        f1_smmry->update_InnerCalls_with_constraints();
        for(std::vector<path_summary_ty *>::iterator it_2 = f2_smmries.begin(); it_2 != f2_smmries.end(); ++it_2)
        {
          path_summary_ty *f2_smmry = *it_2;
          j++;
          llvm::outs() << "Executor::startCompositSymbEx(): Considering the following summaries: (i = "
                       << i << "; j = " << j << ") \n";
          print_function_summary(f1_smmry);
          print_function_summary(f2_smmry);
          if(!comp_symbex_can_glue1(*f1_smmry, *f2_smmry))
          {
            llvm::outs() << "Executor::startCompositSymbEx(): cannot glue\n";
            continue;
          }
          
          /* f1_smmary can glue with f2_smmary => let's create a copy
           * of f1_summary and update its suppl calls. Note that the
           * constructor for PathSummary will create new suppl calls
           * and copy all connected summaries */
          path_summary_ty *f1_smmry_copy = new PathSummary(f1_smmry);
          f1_smmry_copy->clear_connected_summaries_for_inner_calls();

          llvm::outs() << "Executor::startCompositSymbEx(): can glue. Let's add new conditions on arguments\n";
          f1_smmry_copy->update_InnerCalls_with_constraints2(*f2_smmry);
          llvm::outs() << "Executor::startCompositSymbEx(): Running suppl function for " << f1_smmry_copy->fn->getName() << "()\n";
          int res = run_supplementary_functions(*f1_smmry_copy); // Run suppl func for f1_summary
          if(res != 0)
          {
            llvm::outs() << "Executor::startCompositSymbEx(): the following summary chain for " 
                         << f1_smmry_copy->fn->getName() << "() is gluable and has appropriate suppl calls\n";
            f1_smmry_copy->next_path_summary = f2_smmry;
            summaries_to_keep.push_back(f1_smmry_copy);
            for(std::vector<int>::iterator it_3 = f1_smmry_copy->path_choices.begin(); it_3 != f1_smmry_copy->path_choices.end(); ++it_3)
              llvm::outs() << *it_3 << " -> ";
            llvm::outs() << "\n";
            //time_to_start_forwrad_symbex_debug = true;
            //exit(0);
            //print_summary_chains(f1_smmry_copy);
          }
          else
          {
            llvm::outs() << "Executor::startCompositSymbEx(): the following summary chain for " 
                         << f1_smmry_copy->fn->getName() << "() is gluable. We were not able to find suppl calls though.\n";
            delete f1_smmry_copy; // FIXME: memory leak here due to f1_smmry_copy suppl calls
            //llvm::outs() << "Executor::startCompositSymbEx(): cleaning suppl calls\n"; 
          }
          //if(j==2)
          //  exit(0);
        }
      }
      good_path_summaries[f1].clear();
      good_path_summaries[f1].insert(good_path_summaries[f1].begin(), summaries_to_keep.begin(), summaries_to_keep.end());
      llvm::outs() << "Executor::startCompositSymbEx(): good_summaries for " << f1->getName() <<
                      "() contains " << good_path_summaries[f1].size() << " elements now.\n";
      //exit(0);
    }

    llvm::outs() << "\n\n\n\n";
  }

  llvm::outs() << " \n\n\n +++ Executor::startCompositSymbEx(): [FINISHED WITH BACKWARD SYMBEX] \n\n\n";
  //llvm::outs() << " +++ Executor::startCompositSymbEx(): Finished with backward symbex. Here are the collected function summaries.\n";
  //print_function_summaries(good_path_summaries); // Function summaries which go along the call path

                                              /*** Forward symbex ***/

  llvm::outs() << "+++ Executor::startCompositSymbEx():: Starting forward symbex with mainFn= " << mainFn->getName() << "\n";
          
  forward_symbex = 1;
  rand_search_freq = 1; // random 
  prefer_short_summaries = true;
  states.clear();
  for(unsigned k = 0; k<good_path_summaries[(Function *)call_path[0]].size(); k++)
  {
    start_summary = good_path_summaries[(Function *)call_path[0]][k];
    runFunctionAsMain(mainFn, pArgc, pArgv, pEnvp);
  }

}

/* */
void Executor::adapt_psummary_to_inner_call(InnerCall *parent_inner_call, path_summary_ty *smmry)
{
  /* This is very similar to what we do in function runInnerCall() */
  //smmry->clear_connected_summaries_for_inner_calls();

  std::vector<ref<Expr> > ret_conds = parent_inner_call->retval_conditions;
  ret_conds.insert(ret_conds.end(), parent_inner_call->retval_conditions2.begin(),
                     parent_inner_call->retval_conditions2.end());
  
  ref<Expr> result = smmry->return_value;
  ConstantExpr *ce = dyn_cast<ConstantExpr>(result);

  for(call_symbolic_replacements_ty::iterator it_1  = smmry->call_symbolic_replacements.begin();
                                              it_1 != smmry->call_symbolic_replacements.end(); ++it_1)
  {
    ref<Expr> child_symbolics = it_1->first;
    InnerCall *child_inner_call = it_1->second;
    child_inner_call->connected_summaries.clear();
    child_inner_call->retval_conditions.clear();
    child_inner_call->retval_conditions2.clear();

    /* If return value is a call symbolics, we need to pass
     * current retavlue conditions to the corresponding suppl call*/
    if (!ce) 
    {
      //llvm::outs() << "Executor::adapt_psummary_to_inner_call(): result is not a constant! " << result << "\n";
      std::vector<ref<Expr> > symbs = extract_call_symbolics_from_expression(smmry, result);
      //llvm::outs() << "Executor::adapt_psummary_to_inner_call(): result contains " << symbs.size() << " call symbolics.\n";
      assert( (symbs.size() <= 1) && "Complex symbolic return values are not supported yet");

      std::vector<ref<Expr> > concats = extract_concat_subexpressions(result);
      std::vector<ref<Expr> >::iterator it_2 = std::find(concats.begin(), concats.end(), child_symbolics);
      if(it_2 != concats.end())
      {
        llvm::outs() << "Executor::adapt_psummary_to_inner_call(): adding the parent suppl"
                        " call's retval_conditions to suppl call " << child_inner_call->seq_num <<
                        " " << *(child_inner_call->call_inst) << "\n";
        print_expressions(parent_inner_call->retval_conditions);
        print_expressions(parent_inner_call->retval_conditions2);
        child_inner_call->retval_conditions.insert(child_inner_call->retval_conditions.end(),
                     parent_inner_call->retval_conditions.begin(), parent_inner_call->retval_conditions.end());
        child_inner_call->retval_conditions.insert(child_inner_call->retval_conditions.end(),
                     parent_inner_call->retval_conditions2.begin(), parent_inner_call->retval_conditions2.end());
      }
    }
  }
  smmry->update_InnerCalls_with_constraints();
  return;
}

void Executor::runInnerCall(InnerCall &inner_call) 
{
  Function *f1 = inner_call.call_inst->getCalledFunction();
  Function *f2 = NULL;


  std::vector<ref<Expr> > ret_conds = inner_call.retval_conditions;
  ret_conds.insert(ret_conds.end(), inner_call.retval_conditions2.begin(), inner_call.retval_conditions2.end());

  //std::vector< ref<Expr> > *ret_conds = &f_s_retvalue_conds;
   
  std::vector<ref<Expr> > arguments;
  std::vector<llvm::Value *> globals;
  llvm::outs() << "runInnerCall: f1->getName() = " << f1->getName() << "\n";
  // force deterministic initialization of memory objects
  srand(1);
  srandom(1);
  
  MemoryObject *argvMO = 0;

  unsigned NumPtrBytes = Context::get().getPointerWidth() / 8;
  KFunction *kf = kmodule->functionMap[f1];
  assert(kf);

  //llvm::outs() << "Executor::runFunctionAsNonMain(): allocating memory for function arguments (arg_size() = " 
  //             << f->arg_size() << ")\n";
  ExecutionState *state = new ExecutionState(kmodule->functionMap[f1]);

  /// IVAN ADDITIONS BEGIN
  //Setting the target function for the state, i.e. once we reach a call instruction
  //  for this function, we should terminate the state.
  state->target_func = f2;
  //state->ret_value_constraints = ret_conds;
  state->ret_value_constraints = &ret_conds;
  llvm::outs() << "Executor::runInnerCall(): set the target function for the initial state to '"
               << (state->target_func ? state->target_func->getName() : "NULL") << "'\n";
  /// IVAN ADDITIONS END

  
  if (pathWriter) 
    state->pathOS = pathWriter->open();
  if (symPathWriter) 
    state->symPathOS = symPathWriter->open();


  if (statsTracker)
    statsTracker->framePushed(*state, 0);

  llvm::outs() << "Executor::runInnerCall():Going inside initializeGlobals().\n";
  initializeGlobals(*state);
  llvm::outs() << "Executor::runInnerCall():Returned from initializeGlobals().\n";

  processTree = new PTree(state);
  state->ptreeNode = processTree->root;


  // IVAN ADDITIONS BEGIN
  // Making function arguments symbolic
  
  //globals = get_global_calling_context(f); // get the list of global variables which are read and written in the function

  llvm::outs() << "Executor::runInnerCall(): Making function " << f1->getName() << " arguments symbolic\n";
  fargs[f1].clear();
  unsigned numFormals = f1->arg_size();
  unsigned id = 0;
  for (unsigned i=0; i<numFormals; ++i) 
  {
    //static unsigned id;
    unsigned w = 32;

    //llvm::outs() << "DEBUG: symbolic's name : " << "arg_" + f->getName().str() + "_" + llvm::utostr(idi) << "\n";
    llvm::outs() << "Executor::runInnerCall(): making symbolic the following arg:" << getArgumentCell(*state, kf, i).value << "\n";
    const Array *array = Array::CreateArray("arg_" + f1->getName().str() + "_" + llvm::utostr(id), Expr::getMinBytesForWidth(w) );
    ref<Expr> res = Expr::createTempRead(array, w);
    bindArgument(kf, i, *state, res);
    fargs[f1].push_back(res);
    id++;
  }
  llvm::outs() << "Executor::runInnerCall(): fargs[f1].size() = " << fargs[f1].size() << "\n";

  // Making globals which are used in the function symbolic
  llvm::outs() << "Executor::runInnerCall(): Making globals symbolic\n";
  globals = get_global_calling_context(f1); // get the list of global variables which are read and written in the function
  make_globals_symbolic(state, globals); 

  llvm::outs() << "Executor::runInnerCall(): number of global symbolic replacements = " << 
                  state->global_symbolic_replacements.size() << "\n";

  llvm::outs() << "Executor::runInnerCall(): going into run with the following constraints:\n"; 
  print_state_constraints(state);

  comp_symbex_target_reached = 0; // This is set to one when either we reach a ret, satisfying conditions or
                                  // a call to the next function in the call path
  // IVAN ADDITIONS END

  state->cur_inner_call = &inner_call;
  run(*state);

  delete processTree;
  processTree = 0;

  // hack to clear memory objects
  delete memory;
  memory = new MemoryManager();
  memory->arch = this->arch;
  
  globalObjects.clear();
  globalAddresses.clear();

  if (statsTracker)
    statsTracker->done();
}

/* Get bit width if type is an Interger type, 0 otherwise
 */
unsigned getIntTypeWidth(llvm::Type *type)
{
  //if(isa<llvm::IntegerType>(type))
  assert(isa<llvm::IntegerType>(type));
  return (dyn_cast<llvm::IntegerType>(type))->getBitWidth();
  //return 0;
}

/* Get bit width of pointer subtype
 * Return 0 if type is not a PointerType
 */
unsigned getPointerTypeElementWidth(llvm::Type *type)
{
  assert(isa<llvm::PointerType>(type));
  llvm::Type *element_type = (dyn_cast<llvm::PointerType>(type))->getElementType();
  return getIntTypeWidth(element_type);
}

/* TODO: description
 *
 * @param f1 Function to start execution with
 * @param f2 Stop execution when we reach a call to this function
 * @param globals Vector of global variables used in f1. We will make them symbolic in this function
 * @return void
 */
void Executor::runFunctionAsNonMain(Function *f1, Function *f2,
                                    std::vector< ref<Expr> > *ret_conds) 
{
  std::vector<ref<Expr> > arguments;
  std::vector<llvm::Value *> globals;
  llvm::outs() << "\n\n [NEW SYMBEX] runFunctionAsNonMain(): f1->getName() = " << f1->getName() << "\n";
  // force deterministic initialization of memory objects
  srand(1);
  srandom(1);
  
  MemoryObject *argvMO = 0;

  unsigned NumPtrBytes = Context::get().getPointerWidth() / 8;
  KFunction *kf = kmodule->functionMap[f1];
  assert(kf);

  //llvm::outs() << "Executor::runFunctionAsNonMain(): allocating memory for function arguments (arg_size() = " 
  //             << f->arg_size() << ")\n";
  ExecutionState *state = new ExecutionState(kmodule->functionMap[f1]);

  /// IVAN ADDITIONS BEGIN
  //Setting the target function for the state, i.e. once we reach a call instruction
  //  for this function, we should terminate the state.
  state->target_func = f2;
  state->ret_value_constraints = ret_conds;
  llvm::outs() << "Executor::runFunctionAsNonMain(): set the target function for the initial state to '"
               << (state->target_func ? state->target_func->getName() : "NULL") << "'\n";
  /// IVAN ADDITIONS END

  
  if (pathWriter) 
    state->pathOS = pathWriter->open();
  if (symPathWriter) 
    state->symPathOS = symPathWriter->open();


  if (statsTracker)
    statsTracker->framePushed(*state, 0);

  llvm::outs() << "Going inside initializeGlobals().\n";
  initializeGlobals(*state);
  llvm::outs() << "Returned from initializeGlobals().\n";

  processTree = new PTree(state);
  state->ptreeNode = processTree->root;


  // IVAN ADDITIONS BEGIN
  // Making function arguments symbolic
  
  //globals = get_global_calling_context(f); // get the list of global variables which are read and written in the function

  //llvm::outs() << "DEBUG: Making function arguments symbolic\n";
  llvm::outs() << "Executor::runFunctionAsNonMain(): Making function '" << f1->getName() << "()' arguments symbolic\n";
  fargs[f1].clear();
  unsigned numFormals = f1->arg_size();
  unsigned id = 0;
  llvm::Function::arg_iterator arg_it = f1->arg_begin();
  for (unsigned i=0; i<numFormals; ++i) 
  {
    //llvm::Argument arg = *arg_it;
    llvm::Value *arg = arg_it;
    llvm::Type *arg_type = arg->getType();
    unsigned bit_width = 0;
    unsigned w = 0;
    if(isa<llvm::PointerType>(arg_type))
    {
      llvm::outs() << "Executor::runFunctionAsNonMain(): fun arg is a pointer\n";
      w = Context::get().getPointerWidth() / 8;
    }
    else
      w = getIntTypeWidth(arg_type);
    assert(w && "Formal arg width cannot be zero");


    //llvm::outs() << "DEBUG: symbolic's name : " << "arg_" + f->getName().str() + "_" + llvm::utostr(idi) << "\n";
    //llvm::outs() << "Executor::runFunctionAsNonMain(): making symbolic the following arg:" << getArgumentCell(*state, kf, i).value << "\n";
    llvm::outs() << "Executor::runFunctionAsNonMain(): creating new symbolic array with size " << w << "\n";
    const Array *array = Array::CreateArray("arg_" + f1->getName().str() + "_" + llvm::utostr(id), Expr::getMinBytesForWidth(w) );
    ref<Expr> res = Expr::createTempRead(array, w);
    bindArgument(kf, i, *state, res);
    fargs[f1].push_back(res);
    id++;
    ++arg_it;
  }

  // Making globals which are used in the function symbolic
  llvm::outs() << "runFunctionAsNonMain(): Making globals symbolic\n";
  globals = get_global_calling_context(f1); // get the list of global variables which are read and written in the function
  make_globals_symbolic(state, globals); 

  llvm::outs() << "runFunctionAsNonMain(): number of global symbolic replacements = " << 
                  state->global_symbolic_replacements.size() << "\n";

  comp_symbex_target_reached = 0; // This is set to one when either we reach a ret, satisfying conditions or
                                  // a call to the next function in the call path
  // IVAN ADDITIONS END

  build_fsummary_start_timer = time(NULL);
  run(*state);

  delete processTree;
  processTree = 0;

  // hack to clear memory objects
  delete memory;
  memory = new MemoryManager();
  memory->arch = this->arch;
  
  globalObjects.clear();
  globalAddresses.clear();

  if (statsTracker)
    statsTracker->done();
  
  llvm::outs() << "\n\n [END FUNC SYMBEX] runFunctionAsNonMain(): f1->getName() = " << f1->getName() << "\n";
}

unsigned Executor::getPathStreamID(const ExecutionState &state) {
  assert(pathWriter);
  return state.pathOS.getID();
}

unsigned Executor::getSymbolicPathStreamID(const ExecutionState &state) {
  assert(symPathWriter);
  return state.symPathOS.getID();
}

void Executor::getConstraintLog(const ExecutionState &state, std::string &res,
                                Interpreter::LogType logFormat) {

  std::ostringstream info;

  switch (logFormat) {
  case STP: {
    Query query(state.constraints, ConstantExpr::alloc(0, Expr::Bool));
    char *log = solver->getConstraintLog(query);
    res = std::string(log);
    free(log);
  } break;

  case KQUERY: {
    std::string Str;
    llvm::raw_string_ostream info(Str);
    ExprPPrinter::printConstraints(info, state.constraints);
    res = info.str();
  } break;

  case SMTLIB2: {
    std::string Str;
    llvm::raw_string_ostream info(Str);
    ExprSMTLIBPrinter printer;
    printer.setOutput(info);
    Query query(state.constraints, ConstantExpr::alloc(0, Expr::Bool));
    printer.setQuery(query);
    printer.generateOutput();
    res = info.str();
  } break;

  case CVS: {
    //std::ostringstream info;
    //ExprPPrinter::printConstraints(info, state.constraints);
    //res = info.str();    
  } break;

  default:
    klee_warning("Executor::getConstraintLog() : Log format not supported!");
  }
}

bool Executor::getSymbolicSolution(const ExecutionState &state,
                                   std::vector< 
                                   std::pair<std::string,
                                   std::vector<unsigned char> > >
                                   &res) {
  solver->setTimeout(coreSolverTimeout);

  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution: entry point.\n";
  //int aaa;
  //std::cin >> aaa;
  ExecutionState tmp(state);
  //std::cin >> aaa;
  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution: point1.\n";

  // Go through each byte in every test case and attempt to restrict
  // it to the constraints contained in cexPreferences.  (Note:
  // usually this means trying to make it an ASCII character (0-127)
  // and therefore human readable. It is also possible to customize
  // the preferred constraints.  See test/Features/PreferCex.c for
  // an example) While this process can be very expensive, it can
  // also make understanding individual test cases much easier.
  //llvm::outs() << "Number of symbolics = " << state.symbolics.size() << "\n";
  for (unsigned i = 0; i != state.symbolics.size(); ++i) {
    const MemoryObject *mo = state.symbolics[i].first;
    std::vector< ref<Expr> >::const_iterator pi = 
      mo->cexPreferences.begin(), pie = mo->cexPreferences.end();
    for (; pi != pie; ++pi) {
      bool mustBeTrue;
      // Attempt to bound byte to constraints held in cexPreferences
      bool success = solver->mustBeTrue(tmp, Expr::createIsZero(*pi), 
					mustBeTrue);
      // If it isn't possible to constrain this particular byte in the desired
      // way (normally this would mean that the byte can't be constrained to
      // be between 0 and 127 without making the entire constraint list UNSAT)
      // then just continue on to the next byte.
      if (!success) break;
      // If the particular constraint operated on in this iteration through
      // the loop isn't implied then add it to the list of constraints.
      if (!mustBeTrue) tmp.addConstraint(*pi);
    }
    if (pi!=pie) break;
  }
  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution: got through symbolics.\n";

  std::vector< std::vector<unsigned char> > values;
  std::vector<const Array*> objects;
  for (unsigned i = 0; i != state.symbolics.size(); ++i)
    objects.push_back(state.symbolics[i].second);
  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution: going inside solver->getInitialValues().\n";
  bool success = solver->getInitialValues(tmp, objects, values);
  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution: left solver->getInitialValues().\n";
  solver->setTimeout(0);
  if (!success) {
    klee_warning("unable to compute initial values (invalid constraints?)!");
    ExprPPrinter::printQuery(llvm::errs(), state.constraints,
                             ConstantExpr::alloc(0, Expr::Bool));
    return false;
  }
  
  for (unsigned i = 0; i != state.symbolics.size(); ++i)
    res.push_back(std::make_pair(state.symbolics[i].first->name, values[i]));
  return true;
  //llvm::outs() << "DEBUG: Executor::getSymbolicSolution(): finished.\n";
}

void Executor::getCoveredLines(const ExecutionState &state,
                               std::map<const std::string*, std::set<unsigned> > &res) {
  res = state.coveredLines;
}

void Executor::doImpliedValueConcretization(ExecutionState &state,
                                            ref<Expr> e,
                                            ref<ConstantExpr> value) {
  abort(); // FIXME: Broken until we sort out how to do the write back.

  if (DebugCheckForImpliedValues)
    ImpliedValue::checkForImpliedValues(solver->solver, e, value);

  ImpliedValueList results;
  ImpliedValue::getImpliedValues(e, value, results);
  for (ImpliedValueList::iterator it = results.begin(), ie = results.end();
       it != ie; ++it) {
    ReadExpr *re = it->first.get();
    
    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(re->index)) {
      // FIXME: This is the sole remaining usage of the Array object
      // variable. Kill me.
      const MemoryObject *mo = 0; //re->updates.root->object;
      const ObjectState *os = state.addressSpace.findObject(mo);

      if (!os) {
        // object has been free'd, no need to concretize (although as
        // in other cases we would like to concretize the outstanding
        // reads, but we have no facility for that yet)
      } else {
        assert(!os->readOnly && 
               "not possible? read only object with static read?");
        ObjectState *wos = state.addressSpace.getWriteable(mo, os);
        wos->write(CE, it->second);
      }
    }
  }
}

Expr::Width Executor::getWidthForLLVMType(LLVM_TYPE_Q llvm::Type *type) const {
  return kmodule->targetData->getTypeSizeInBits(type);
}

///

Interpreter *Interpreter::create(const InterpreterOptions &opts,
                                 InterpreterHandler *ih) {
  return new Executor(opts, ih);
}

/// IVAN ADDITIONS START
//
std::string Executor::fvector_to_string(Executor::FVector fvector)
{
  std::string ret = fvector[0]->getName().str() + "()";
  int sz = fvector.size();
  int i;
  for(i=1;i<sz;i++)
    ret = ret + " -> " +  fvector[i]->getName().str() + "()";
  return ret;
}

/* Classic Dijkstra algorithm for finding shortets paths
 *
 * @param call_graph look for shortest paths in this graph
 * @param V number of vertices in the graph
 * @param st the source vertex for Dijkstra algorithm
 */
Executor::FVector Executor::Dijkstra_call_graph(llvm::CallGraph &call_graph, llvm::CallGraphNode *st, llvm::CallGraphNode *target_node)
{
  Executor::FVector ret;
  int count;
  int num_vertices = 0;
  unsigned int min_=UINT_MAX;
  unsigned int v_dist = UINT_MAX;
  std::string st_name = st->getFunction()->getName();
  llvm::CallGraphNode *u = NULL; // u is the current node with minumum distance to the source,
  llvm::CallGraphNode *v = NULL; // v is used when we iterate
  std::map<llvm::CallGraphNode *, unsigned int> distance;
  std::set<llvm::CallGraphNode *> visited;
  std::map<llvm::CallGraphNode *,Executor::FVector>  path; // Executor::FVector contains functions in between

  //std::map<llvm::CallGraphNode *, const llvm::Function *> nodeToFunc; /* We need this map since CllaGraphNode::CallRecord::getFunctio() returns NULL sometimes  */

  for (llvm::CallGraph::iterator it = call_graph.begin(); it != call_graph.end(); ++it)
  {
    v = it->second;  // v is a CallRecord, we need to extract CallGraphNode from it.
    //const llvm::Function *v_func = it->first;
    llvm::Function *v_func = v->getFunction();
    if (v_func == NULL)
      continue;
    //llvm::outs() << "Executor::Dijkstra_call_graph(): adding node for function " << v_func->getName() << "().\n";
    llvm::outs() << "Executor::Dijkstra_call_graph(): adding node for function " << 
                    v->getFunction()->getName() << "() @ " << v << ".\n";
    num_vertices++;
    //if (v != st)
    distance[v] = UINT_MAX;
    path[v].push_back(st->getFunction());
    //nodeToFunc[v] = v_func;
  }
  distance[st]=0;

  llvm::outs() << "Executor::Dijkstra_call_graph(): number of vertices on the callgraph = " << num_vertices << ".\n";

  for (count=0; count<num_vertices-1; count++)
  {
    min_=UINT_MAX;

    /* Iterate through all nodes (including the source node) and find the node
     * with minumum distance to source. During the first outer loop
     * iteration it's going to be the source node.
     */
    llvm::outs() << "Executor::Dijkstra_call_graph(): **** ; distance.size() = " << distance.size() << "\n";
    u = NULL;
    unsigned ind;
    ind = 0;
    for (std::map<llvm::CallGraphNode *,unsigned int>::iterator it=distance.begin(); it!=distance.end(); ++it)
    {
      v = it->first;
      v_dist = it->second;
      llvm::outs() << "Executor::Dijkstra_call_graph(): distance[" << ind << "] = " << v_dist 
                   << " v = " << v << "(" << v->getFunction()->getName() << ").\n";
      if(visited.count(v))
        llvm::outs() << "Executor::Dijkstra_call_graph(): skipping distance[" << ind << "] = " << v_dist << ".\n";
      if (!(visited.count(v)) && (v_dist < min_) )
      {
          min_ = v_dist;
          llvm::outs() << "Executor::Dijkstra_call_graph(): min_ = " << v_dist << ".\n";
          llvm::outs() << "Executor::Dijkstra_call_graph(): u changed to " << v->getFunction()->getName() << ".\n";
          u = v;
      }
      ind++;
    }
    if(!u)
    {
      if(path[target_node].size() == 1)
        klee_error("No call path to target function\n");
      return path[target_node];
    }

    visited.insert(u);
    if(u->getFunction())
      llvm::outs() << "Executor::Dijkstra_call_graph(): we have new current node u: " << u->getFunction()->getName() <<
                   "; it has " << u->size() << " neighbours.\n";
    else
      llvm::outs() << "Executor::Dijkstra_call_graph(): we have new current node u: NULL.\n";
    //llvm::outs() << "Executor::Dijkstra_call_graph(): we have new current node: " << nodeToFunc[u]->getName() << ".\n";

    llvm::outs() << "Executor::Dijkstra_call_graph(): ++++ ; distance.size() = " << distance.size() << "\n";
    /* Go through all unvisited neighbours of <u> and update their
     * distances to the source to DIST(u)+1 */
    for (llvm::CallGraphNode::iterator cr = u->begin(), cr_end = u->end(); cr != cr_end; ++cr)
    {
      v = cr->second;  // cr is a CallGraphNode::CallRecord, we need to extract CallGraphNode from it.
      if(!distance.count(v))
      {
        llvm::outs() << "Executor::Dijkstra_call_graph(): Warning no distance information for neighbour v = " << v << " (skipping)!\n"; 
        continue;
      }
      //llvm::outs() << "                                 $$ ; neighbour = " << v->getFunction()->getName() <<
      llvm::outs() << "                                 $$ ;" <<
                                                        " u = " << u << "; v = " << v << 
                                                        "; distance.size() = " << distance.size() << "\n";
      if ( !visited.count(v)  && (distance[u] != UINT_MAX) &&  ((distance[u]+1) < distance[v]) )
      {
        distance[v] = distance[u]+1;
        llvm::outs() << "Executor::Dijkstra_call_graph(): new distance for: " << v->getFunction()->getName()
                     << "() = " << distance[v] << ", v = " << v << "; u = " << u << ".\n";
        path[v].assign(path[u].begin(), path[u].end());
        path[v].push_back(v->getFunction());
      }
      llvm::outs() << "                                 $$2 ;" <<
                                                        " u = " << u << "; v = " << v << 
                                                        "; distance.size() = " << distance.size() << "\n";
    }
    llvm::outs() << "Executor::Dijkstra_call_graph(): ---- ; distance.size() = " << distance.size() << "\n";
  }
  return path[target_node];
}

bool contains_ret_instr(BasicBlock *b)
{
    for (BasicBlock::iterator i = b->begin(), ie = b->end(); i != ie; ++i)
    {
      ReturnInst* retInst = dyn_cast<ReturnInst>(&*i);
      if (retInst)
      {
	      return true;
      }
    }
    return false;
}

// If target_bb is NULL, then the target block is the one which contains ret instruction
Executor::BBVector Executor::Dijkstra_cfg(llvm::Function *parent_f,
                                          llvm::BasicBlock *entry_bb,
                                          llvm::BasicBlock *target_bb,
                                          std::vector<std::pair<llvm::BasicBlock *, llvm::BasicBlock *> > *exclude_arcs)
{
  assert(parent_f && "Start function cannot be NULL");
  assert(entry_bb && "Start node (basic block) cannot be NULL");
  Executor::BBVector ret;
  int count;
  int num_vertices = 0;
  int min_=INT_MAX;
  //string st_name = st->getFunction()->getName();
  llvm::BasicBlock *u; // u is the current node with minumum distance to the source,
  llvm::BasicBlock *v; // v is used when we iterate
  std::map<llvm::BasicBlock *,int> distance;
  std::set<llvm::BasicBlock *> visited;
  std::map<llvm::BasicBlock *, Executor::BBVector> path; // Executor::BBVector contains blocks between entry_bb and another basicblock

  // Initialization: find number of vertices, set distance to infinity, set the first node in the path as entry_bb
  for (llvm::Function::iterator v = parent_f->begin(); v != parent_f->end(); ++v) // v is BasicBlock iterator
  {
    num_vertices++;
    distance[(&*v)] = INT_MAX;
    path[(&*v)].push_back(entry_bb); // Beginning of each path is entry basic block
    // If taget_bb == NULL, the the caller of this function asked us to make a path from entry to RET instruction
    if(!target_bb && contains_ret_instr(&*v))
    {
      target_bb = &*v;
      //#define IVAN
      #ifdef IVAN
      const llvm::TerminatorInst *t_inst = target_bb->getTerminator();
      outs() <<  "Function " << parent_f->getName() 
	     << ": basic block has ret instruction:\n      " 
	     << *t_inst << "\n";
      #endif
      #undef IVAN
    }
    
  }
  distance[entry_bb]=0;

  for (count=0; count<num_vertices-1; count++)
  {
    min_=INT_MAX;
    // Find the node with minumum distance to source
    for (std::map<llvm::BasicBlock *,int>::iterator it=distance.begin(); it!=distance.end(); ++it)
    {
      v = it->first;
      int v_dist = it->second;
      if (!visited.count(v) && v_dist <= min_)
        {min_=v_dist; u=v;}
    }
    // Mark node as visited: we will parse all its neightbours below
    visited.insert(u);
    // Go through all neightbours of the the minimum-distance node
    const llvm::TerminatorInst *TInst = u->getTerminator();
    //for (CallGraphNode::iterator cr = u->begin(), cr_end = u->end(); cr != cr_end; ++cr)
    for (unsigned i = 0, NSucc = TInst->getNumSuccessors(); i < NSucc; ++i) 
    {
      llvm::BasicBlock *v = TInst->getSuccessor(i);
      // Skip neighbours for which we exluded arcs to them
      if(exclude_arcs && (std::find(exclude_arcs->begin(), exclude_arcs->end(), std::make_pair(u,v)) != exclude_arcs->end()))
        continue;
      if ( !visited.count(v)  && distance[u]!=INT_MAX &&  distance[u]+1 < distance[v])
      {
        distance[v]=distance[u]+1;
        path[v].assign(path[u].begin(), path[u].end());
        path[v].push_back(v);
      }
    }
  }
  //assert( (*(path[target_bb].end()-1) == target_bb) && "Path to target_bb does not end at target_bb");
  // If there is no path from entry_bb to target_bb, return emtpy vector
  if(*(path[target_bb].end()-1) != target_bb)
  {
    Executor::BBVector v;
    return v;
  }
  return path[target_bb];
}

//Executor::FVector Executor::get_call_graph_path(llvm::Module *Mod, llvm::Function *entry_func, llvm::Function *target_func)
Executor::FVector Executor::get_call_graph_path(llvm::Function *entry_func, llvm::Function *target_func)
{
  if(target_func == NULL)
    klee_error("Could not find target function in the code: %s()\n",target_func->getName().str().c_str());
  if(entry_func == NULL)
    klee_error("Could not find entry function in the code: %s()\n",entry_func->getName().str().c_str());

  llvm::outs() << "Creating call graph: " << entry_func->getName() << " -- " << target_func->getName() << ".\n";
  //llvm::Function *entry_func = NULL;
  //llvm::Function *target_func = NULL;

  /* Note: the following code moved to path_main_routine()
  for (llvm::Module::iterator f = Mod->begin(), fe = Mod->end(); f != fe; ++f)
  {
    if( f && f->getName() == entry_func_name)
      entry_func = (&*f);
    if( f && f->getName() == target_func_name)
      target_func = (&*f);
    should_collect_more_summaries[&*f] = true;
  } */


  llvm::CallGraph call_graph;
  //call_graph.runOnModule(*Mod);
  call_graph.runOnModule(*(kmodule->module));
  llvm::outs() << "Call graph is created.\n";
  llvm::CallGraphNode *entry_node  = call_graph[entry_func];
  llvm::CallGraphNode *target_node = call_graph[target_func];
  Executor::FVector path_to_target = Dijkstra_call_graph(call_graph, entry_node, target_node);
  llvm::outs() << "Path to target node: " << entry_func->getName() << "() > " << target_func->getName() << 
               "(): " << fvector_to_string(path_to_target) << "\n";
  return path_to_target;
}


/* Find path call instruction for f2 inside function f1
 *
 * If there is no such instruction, return the last (i.e. RET) instruction of f1
 *
 * @param f1 Function in which search for the call instruction
 * @param f2 Funcition which should be argument of the call instruction
 * @return Call f2 instruction, if it is found. Last RET instruction of f1 otherwise.
 */
Instruction *Executor::get_call_inst(Function *f1, Function *f2)
{
  Instruction *target_inst = NULL;
  for (Function::iterator b = f1->begin(), be = f1->end(); b != be; ++b)
    for (BasicBlock::iterator i = b->begin(), ie = b->end(); i != ie; ++i)
    {
        CallInst* callInst = dyn_cast<CallInst>(&*i);
        if (callInst)
        {
          Function *callee = callInst->getCalledFunction();
          if(callee == f2)
            outs() << "Found call to " << f2->getName() << "() from " << f1->getName() << "(). Building path from the function entry to the call instruction.\n";
          //target_func = (&*f);
          target_inst = (&*i);
        }
    }
  return target_inst;
}


// Get path from f1's entry to call f2
/* Build path from f1's entry block to call f2 instruction (path is a
 * BBVector of f1's basic blocks.
 *
 * @param f1 Function for which to build the path.
 * @param f2 Function which is called from f1.
 * @return BBVector of f1's basic blocks which lead to Call f2 instruction
 *         If there is no such call, the path is between f1's entry and return
 *         instruction.
 */
Executor::BBVector Executor::get_cfg_path(Function *f1, Function *f2)
{  
  Instruction *target_inst = NULL;
  BasicBlock *target_bb = NULL;
  BasicBlock *entry_bb = NULL;
 
  entry_bb = &f1->getEntryBlock();
  target_inst = get_call_inst(f1, f2);
  target_bb = target_inst->getParent();

  //outs() << *target_inst << "\n";
  // Now find shortest path (in terms of basic blocks between entry_bb and target_bb)
  Executor::BBVector path_to_target =  Dijkstra_cfg(f1, entry_bb, target_bb, NULL);

  //#define IVAN
  #ifdef IVAN
  int sz = path_to_target.size();
  int i;
  outs() << "Path in " << f1->getName() << "() to " << f2->getName() << "()\n";
  for(i=0;i<sz;i++)
  {
    const Instruction* first_inst = path_to_target[i]->getFirstNonPHIOrDbg();
    outs() << " - First inst of block " << i << ": " << *first_inst << "\n";
  }
  #endif
  #undef IVAN

  return path_to_target;
}

//int Executor::search_for_call_instructions(std::set<Instruction *> inst_set, FVector already_analyzed)
//{
//  for(std::set<Instruction *>::iterator i = inst_set.begin(); i != inst_set.end(); ++i)
//  {
//     CallInst* callInst = dyn_cast<CallInst>(*i);
//     if (callInst)
//     {
//       Function *callee = callInst->getCalledFunction();
//       if(std::find(already_analyzed.begin(), already_analyzed.end(), callee) != already_analyzed.end())
//       {
//         outs() << "Found call to " << callee->getName() << "() among our path instructions\n";
//	 already_analyzed.push_back(callee);
//       }
//     }
//  }
//  return 0;
//}

/* Description
 * 
 * @param cfg_paths shortest paths in control flow graph in corresponding functions. Changed in this function.
 * @param path_functions contains keys for cfg_paths. Changed in this function.
 * @return always 0
 */
int Executor::expand_call_instructions(std::map<Function *, BBVector> &cfg_paths, FVector &path_functions)
{
  int num_funs = path_functions.size();
  for(int k = 0; k<num_funs; k++)  // for each function in <path_functionss>
  {
    Function *f = (Function *)path_functions[k];
    BBVector bbvector = cfg_paths[f];
    int num_blocks = bbvector.size();
    for(int j = 0; j<num_blocks; j++) // for each basicblock <b> in <path_functions[k]>
    {
      BasicBlock *b = (BasicBlock *)bbvector[j];
      for(BasicBlock::const_iterator i = b->begin(); i != b->end(); ++i) // for each instruction <i> in block <b>
      {
        CallInst* callInst = dyn_cast<CallInst>((Instruction *)(&*i));
        if (callInst)
        {
          Function *callee = callInst->getCalledFunction();
	        // If: (callee is not NULL) AND (we don't have callee in our path_functions vector yet)
          if(callee && !callee->isDeclaration() && (std::find(path_functions.begin(), path_functions.end(), callee) == path_functions.end()))
          {
            outs() << "Found a call to unexplored function " << callee->getName() << "() among our path instructions. Building path from this function's entry to ret.\n";
	          BBVector path_through_callee = Dijkstra_cfg(callee, &callee->getEntryBlock(), NULL, NULL); // first NULL means we need a path to ret instruction

            path_functions.push_back(callee);
            cfg_paths[callee] = path_through_callee;
            //#define IVAN
            #ifdef IVAN
            int sz = path_through_callee.size();
            outs() << "Path through " << callee->getName() << "():\n";
            for(int i=0;i<sz;i++)
            {
              const Instruction* first_inst = path_through_callee[i]->getFirstNonPHIOrDbg();
              outs() << " - First inst of block " << i << ": " << *first_inst << "\n";
            }
            #endif
            #undef IVAN
            num_funs++;
            //return 0;
            //outs() << "Found a call to unexplored function among our path instructions\n";
            //already_analyzed.push_back(callee);
          }
        }
      } // for each instruction
    } // for each basicblock
  } // for each function
  return 0;
}

/* Print blocks which belong to the path
 *
 * @param f the top level function
 * @param level call-level, used for recursion
 * @return always 0
 */
//int Executor::print_path1(const Function *f, int level)
//{
//  //std::stack<int> fun_ndx_stack;
//  std::string f_name = f->getName().str();
//  if(level == 0)
//  {
//    outs() << "Printing the shortest combined control-flow-path.\n";
//    outs() << std::string(level*3,' ') << f_name << ":\n";
//  }
//  //outs() << std::string(std::max((level-1)*3,0), ' ' ) << f_name << ":\n";
//  //outs() << std::string(level*3,' ') << f_name << ":\n";
//
//  BBVector bbvector = cfg_paths[(Function *)f];
//  int num_blocks = bbvector.size();
//  for(int j = 0; j<num_blocks; j++) 
//  {
//    BasicBlock *b = (BasicBlock *)bbvector[j];
//    outs() << std::string(level*3+2, ' ' ) << f_name << ".bb_" << j << "\n";
//    for(BasicBlock::const_iterator i = b->begin(); i != b->end(); ++i) // for each instruction <i> in block <b>
//    {
//      CallInst* callInst = dyn_cast<CallInst>((Instruction *)(&*i));
//      if (callInst)
//      {
//        Function *callee = callInst->getCalledFunction();
//        if(callee)
//        {
//          //outs () << "DEBUG: " << callee->getName() << " @" << callee << "\n";
//          assert((std::find(path_functions.begin(), path_functions.end(), callee) != path_functions.end()) && "Function called from path is not in path ");
//          outs() << std::string(level*3+2,' ') << callee->getName() << ":\n";
//          print_path1(callee,level+1);
//        }
//      }
//      ReturnInst* retInst = dyn_cast<ReturnInst>((Instruction *)(&*i));
//      if (retInst)
//          outs() << std::string(level*3+2,' ') << "RETN\n";
//    } // for each instruction
//  } // for each basicblock
//  return 0;
//}




/* Arc src -> dst is unreachable in the call graph. We need to find the second shortest path
 * Originally we made a path either (entry -> .. -> return)
 * or (entry -> .. -> call instruction to next function in call graph).*/
int Executor::rebuildInfeasableCFGPath(BasicBlock *src, BasicBlock *dst)
{
  Function *f = src->getParent(); // The function for which we rebuild the cfg path

  std::vector<std::pair<BasicBlock *,BasicBlock*> > v;
  v.push_back(std::make_pair(src,dst));

  BasicBlock *entry = (BasicBlock *) *(cfg_paths[f].begin()); // We need to make another path from the same entry 
  BasicBlock *target = (BasicBlock *) *(cfg_paths[f].end()-1); // to the same last block (eitherfunction call or RET instruction)

  Executor::BBVector new_path =  Dijkstra_cfg(f, entry, target, &v);
  if(new_path.size() == 0)
  {
    outs() << "DEBUG: rebuildInfeasableCFGPath(): could not build new path, the arc is in the cut set. Staying with old path\n";
    return 0;
  }

  cfg_paths[f] = new_path;
  expand_call_instructions(cfg_paths, path_functions); // Go through function which we need to go through and add correspnding shortest paths.
  path.clear(); // Clear interprocedural path. If we don't do that, then the new path will be appended to the old one.
  build_path(path_functions[0]); // Build a new interprocedural path
  return 0;
  //BBVector f_old_path = std::find(cfg_paths[f]);
  //BBVector::iterator it = std::find(f_old_path.begin(), f_old_path.end(), src);
  //assert( it != f_old_path.end() && "src is not found in the original path");

}

/* Build the overall path using cfg_paths. TODO: should be fixed (see
 * the problem in the description)
 *
 * Building the path start from the start function (usually it is "main"
 * function). The key idea is that we go deeper into the calling
 * hierarchy and finally should arrive arrive to our destination
 * function. TODO: The problem with this approach: this works if we
 * have a function call along our path: we go from the entry to the RET
 * instruction and all intermediate call should be indeed in our
 * path_function. However, consider the functions from our call_path.
 * They should not be covered completely but only until the call to the
 * next function in call_path is made. So we add additional wrong blocks
 * to the path. It works for all see, because call printGesture() is in
 * the last block of main(). However in other programs it will not be
 * case. Another issue is that we can have multiple call paths to the
 * target function
 *
 * @param f The entry function of our path toward the target.
 * @return Always 0.
 */
int Executor::build_path(const Function *f)
{
  BBVector bbvector = cfg_paths[(Function *)f];
  int num_blocks = bbvector.size();
  for(int j = 0; j<num_blocks; j++) 
  {
    BasicBlock *b = (BasicBlock *)bbvector[j];
    path.push_back(std::make_pair(b,(Instruction*)NULL));
    for(BasicBlock::const_iterator i = b->begin(); i != b->end(); ++i) // for each instruction <i> in block <b>
    {
      CallInst* callInst = dyn_cast<CallInst>((Instruction *)(&*i));
      if (callInst)
      {
        Function *callee = callInst->getCalledFunction();
        if(callee && !(callee->isDeclaration()))
        {
          path.push_back(std::make_pair((BasicBlock*)NULL,callInst));
          assert((std::find(path_functions.begin(), path_functions.end(), callee) != path_functions.end()) && "Function called from path is not in path ");
          build_path(callee);
          // If this is a call to a function in our call_path, we do not need to add new blocks to the path.
          if(std::find(call_path.begin(), call_path.end(), callee) != call_path.end())
            return 0;
          path.push_back(std::make_pair(b,(Instruction*)NULL)); // We return to the same block, but path has advanced. To reflect we add another copy of the same block
        }
      } else
      {
        ReturnInst* retInst = dyn_cast<ReturnInst>((Instruction *)(&*i));
        if (retInst)
          path.push_back(std::make_pair((BasicBlock*)NULL,retInst));
      }
    } // for each instruction
  } // for each basicblock
  return 0;
}

std::vector<llvm::CallInst *> Executor::extract_call_insts_from_path()
{
  std::vector<llvm::CallInst *> res;
  int path_len = path.size();
  for(int j = 0; j<path_len; j++) 
  {
    BasicBlock *block = path[j].first;
    Instruction *inst = path[j].second;
    assert( (block || inst) && "Both block and instruction in a path pair are NULL");
    if (inst)
    {
      CallInst* callInst = dyn_cast<CallInst>((Instruction *)(inst));
      if (callInst)
      {
        Function *callee = callInst->getCalledFunction();
        assert(callee);
        res.push_back(callInst);
      }
    }
  }
  return res;
}

int Executor::print_path2()
{
  int INDENT = 2;
  BasicBlock *first_block = path[0].first;
  outs() << "Printing the shortest combined control-flow-path.\n";
  outs() << first_block->getParent()->getName() << ":\n";
  int level = 1;
  int path_len = path.size();
  for(int j = 0; j<path_len; j++) 
  {
    BasicBlock *block = path[j].first;
    Instruction *inst = path[j].second;
    assert( (block || inst) && "Both block and instruction in a path pair are NULL");

    if(block)
    {
      outs() << std::string(level*INDENT, ' ' ) << block->getParent()->getName() << ".bb_" << j << "\n";
    }
    else if (inst)
    {
      CallInst* callInst = dyn_cast<CallInst>((Instruction *)(inst));
      if (callInst)
      {
        Function *callee = callInst->getCalledFunction();
        assert(callee);
        outs() << std::string(level*INDENT,' ') << callee->getName() << ":\n";
        level++;
      }
      else // it should be return instrucion, as in path we only keep callInst and retInst
      {
        ReturnInst* retInst = dyn_cast<ReturnInst>((Instruction *)(inst));
        assert(retInst && "Path instruction is neither callInst nor retInst");
        outs() << std::string(level*INDENT,' ') << "RETN\n";
        level--;
      }
    }
  }
  return 0;
}


// TODO: compare basic blocks instead of instructions
int Executor::combine_instructions()
{
  //std::set<Instruction *> ret;
  for(std::map<Function*, Executor::BBVector>::iterator it=cfg_paths.begin(); it!=cfg_paths.end(); ++it)
  {
     BBVector bbvector = it->second;
     int sz = bbvector.size();
     for(int k = 0; k<sz; k++)
       for (BasicBlock::const_iterator inst = bbvector[k]->begin(), inst_e = bbvector[k]->end(); inst != inst_e; ++inst)
           path_instructions.insert((Instruction* )(&*inst));
  }
  return 0;
}

/* Construct interprocedural path from start function to target
 * function.
 *
 * Build: call_path, cfg_paths for each function on the path, and path
 * (which is a sequence of blocks and call and ret instructions).  If
 * start_function = target_function then path is constructed from entry
 * to return of this function.
 *
 * @param start_function Start symbolic execution from this function
 *                       (i.e. it is the parameter to runFunctionAsMain())
 * @param target_function Construct path towards call to this funtion
 */
int Executor::path_main_routine(std::string start_function_name, std::string target_function_name)
{
  this->start_function_name = start_function_name;
  this->target_function_name = target_function_name;

  this->start_function = NULL;
  this->target_function = NULL;

  /*  Find start and target functions by their names 
   *  Mark each funtio in the module as requiring summaries*/
  for (llvm::Module::iterator f = kmodule->module->begin(), fe = kmodule->module->end(); f != fe; ++f)
  {
    if( f && f->getName() == start_function_name)
      this->start_function = (&*f);
    if( f && f->getName() == target_function_name)
      this->target_function = (&*f);
    should_collect_more_summaries[&*f] = true;
  }
  if(this->target_function == NULL)
    klee_error("Could not find target function '%s()' in the code\n",target_function_name.c_str());
  if(this->start_function == NULL)
    klee_error("Could not find start function '%s()' in the code\n",start_function_name.c_str());


  llvm::outs() << "Going inside get_call_graph_path().\n";
  //call_path = get_call_graph_path(kmodule->module, "getGesture", "getGesture");
  //call_path = get_call_graph_path(kmodule->module, this->start_function, this->target_function);
  call_path = get_call_graph_path(this->start_function, this->target_function);
  path_functions.assign(call_path.begin(), call_path.end());

  int sz = call_path.size();
  outs() << "Constructing cfg paths for each function in call graph, call path size = " << sz << "\n";

  assert((sz > 1) && "Call patht should be at least of length 2!");
  /*if (sz == 1) // sz = 1 means that target_fun (i.e. assert()) is called directly from start_function (i.e. from main()) .
               // TODO: we should take into account recursion.
  {
    llvm::Function *f1 = (Function *)call_path[0];

    Instruction *target_inst = NULL;
    BasicBlock *target_bb = NULL;

    llvm::BasicBlock *entry_bb = &f1->getEntryBlock();
    target_inst = get_call_inst(f1, this->target_function);
    target_bb = target_inst->getParent();


    Executor::BBVector path_to_target =  Dijkstra_cfg(f1, entry_bb, target_bb, NULL); // target = NULL => we are interested in path to ret instruction
    //exit(0);
    cfg_paths[f1] = path_to_target;
  } 
  else*/

    for (int i=0;i<sz-1;i++)
    {
      llvm::Function *f1 = (Function *)call_path[i];
      llvm::Function *f2 = (Function *)call_path[i+1];
      cfg_paths[f1] = get_cfg_path(f1,f2);
    }  

  outs() << "CFG paths constructed, expanding call instructions.\n";
  expand_call_instructions(cfg_paths, path_functions); // Go through function which we need to go through and add corresponding shortest paths.
  sz = path_functions.size();
  outs() << "Expanded, path goes through the following functions (" << sz << " functions):\n";
  for (int i=0;i<sz;i++)
    outs() << "path_funtions[" << i << "]->getName() = " << path_functions[i]->getName() << " @ " << path_functions[i] << "\n";
  outs() << "\n";
  build_path(path_functions[0]);
  print_path2();
  return 0;
}


/// IVAN ADDITIONS END


